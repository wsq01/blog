---
title: MySQL 函数
date: 2020-04-29 18:14:41
tags: [MySQL]
categories: [MySQL]
---


常用的函数有字符串函数、日期函数和数值函数。 在 MySQL 数据库中，函数可以用在`SELECT`语句及其子句（例如`where`、`order by`、`having`等） 中，也可以用在`UPDATE、DELETE`语句及其子句中。
# 字符串函数

| 函数 | 说明 |
| :--: | :--: |
| CANCAT(S1,S2,…Sn) | 连接 S1, S2, …Sn 为一个字符串 |
| INSERT(str,x,y,instr) | 将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr |
| LOWER(str) | 将字符串 str 中所有字符变为小写 |
| UPPER(str) | 将字符串 str 中所有字符变为大写 |
| LEFT(str ,x) | 返回字符串 str 最左边的 x 个字符 |
| RIGHT(str,x) | 返回字符串 str 最右边的 x 个字符 |
| LPAD(str,n ,pad) | 用字符串 pad 对 str 最左边进行填充，直到长度为 n 个字符长度 |
| RPAD(str,n,pad) | 用字符串 pad 对 str 最右边进行填充，直到长度为 n 个字符长度 |
| LTRIM(str) | 去掉字符串 str 左侧的空格 |
| RTRIM(str) | 去掉字符串 str 行尾的空格 |
| REPEAT(str,x) | 返回 str 重复 x 次的结果 |
| REPLACE(str,a,b) | 用字符串 b 替换字符串 str 中所有出现的字符串 a |
| STRCMP(s1,s2) | 比较字符串 s1 和 s2 |
| TRIM(str) | 去掉字符串行尾和行头的空格 |
| SUBSTRING(str,x,y) | 返回从字符串 str x 位置起 y 个字符长度的字串 |

```sql
SELECT CONCAT( 'aaa', 'bbb', 'ccc' ), CONCAT( 'aaa', NULL );
/*
+---------------------------+--------------------+
| CONCAT('aaa','bbb','ccc') | CONCAT('aaa',null) |
+---------------------------+--------------------+
|         aaabbbccc         |        NULL        |
+---------------------------+--------------------+
*/
SELECT INSERT( 'beijing2008you', 12, 3, 'me' );
/*
+-------------------------------------+
| INSERT('beijing2008you',12,3, 'me') |
+-------------------------------------+
|            beijing2008me            |
+-------------------------------------+
*/
SELECT LOWER( 'BEIJING2008' ), UPPER( 'beijing2008' );
/*
+----------------------+----------------------+
| LOWER('BEIJING2008') | UPPER('beijing2008') |
+----------------------+----------------------+
|     beijing2008      |     BEIJING2008      |
+----------------------+----------------------+
*/
SELECT LEFT('beijing2008', 7), LEFT('beijing', null), RIGHT('beijing2008', 4);
/*
+-----------------------+----------------------+------------------------+
| LEFT('beijing2008',7) | LEFT('beijing',null) | RIGHT('beijing2008',4) |
+-----------------------+----------------------+------------------------+
|        beijing        |                      |          2008          |
+-----------------------+----------------------+------------------------+
*/
SELECT LPAD( '2008', 20, 'beijing' ), RPAD( 'beijing', 20, '2008' );
/*
+---------------------------+---------------------------+
| lpad('2008',20,'beijing') | rpad('beijing',20,'2008') |
+---------------------------+---------------------------+
|   beijingbeijingbe2008    |   beijing2008200820082    |
+---------------------------+---------------------------+
*/
SELECT LTRIM(str)( ' |beijing' ), RTRIM(str)( 'beijing| ' );
/*
+--------------------+--------------------+
| ltrim(' |beijing') | rtrim('beijing| ') |
+--------------------+--------------------+
|       |beijing     |      beijing|      |
+--------------------+--------------------+
*/
SELECT REPEAT('mysql ',3);
/*
+--------------------+
| repeat('mysql ',3) |
+--------------------+
| mysql mysql mysql  |
+--------------------+
*/
SELECT REPLACE('beijing_2010','_2010','2008');
/*
+----------------------------------------+
| replace('beijing_2010','_2010','2008') |
+----------------------------------------+ 
|              beijing2008               |
+----------------------------------------+
*/
SELECT STRCMP('a','b'), STRCMP('b','b'), STRCMP('c','b');
/*
+-----------------+-----------------+-----------------+
| strcmp('a','b') | strcmp('b','b') | strcmp('c','b') |
+-----------------+-----------------+-----------------+
|       -1        |        0        |        1        |
+-----------------+-----------------+-----------------+
*/
SELECT TRIM(' $ beijing2008 $ ');
/*
+---------------------------+
| trim(' $ beijing2008 $ ') |
+---------------------------+
|      $ beijing2008 $      |
+---------------------------+
*/
SELECT SUBSTRING('beijing2008', 8, 4), SUBSTRING('beijing2008', 1, 7);
/*
+------------------------------+------------------------------+
| substring('beijing2008',8,4) | substring('beijing2008',1,7) |
+------------------------------+------------------------------+
|             2008             |           beijing            |
+------------------------------+------------------------------+
*/
```
# 数值函数

| 函数 | 说明 |
| :--: | :--: |
| ABS(x) | 返回 x 的绝对值 |
| CEIL(x) | 返回大于 x 的最大整数值 |
| FLOOR(x) | 返回小于 x 的最大整数值 |
| MOD(x，y) | 返回 x/y 的模 |
| RAND() | 返回 0 到 1 内的随机值 |
| ROUND(x,y) | 返回参数 x 的四舍五入的有 y 位小数的值 |
| TRUNCATE(x,y) | 返回数字 x 截断为 y 位小数的结果 |

```sql
SELECT ABS(- 0.8 ), ABS( 0.8 );
/*
+-----------+----------+
| ABS(-0.8) | ABS(0.8) |
+-----------+----------+
|    0.8    |    0.8   |
+-----------+----------+
*/
SELECT CEIL(-0.8), CEIL(0.8);
/*
+------------+-----------+
| CEIL(-0.8) | CEIL(0.8) |
+------------+-----------+
|     0      |     1     | 
+------------+-----------+
*/
SELECT FLOOR(-0.8), FLOOR(0.8);
/*
+-------------+------------+
| FLOOR(-0.8) | FLOOR(0.8) |
+-------------+------------+
|     -1      |     0      |
+-------------+------------+
*/
SELECT MOD(15,10), MOD(1,11), MOD(NULL,10);
/*
+------------+-----------+--------------+
| MOD(15,10) | MOD(1,11) | MOD(NULL,10) |
+------------+-----------+--------------+
|     5      |     1     |     NULL     |
+------------+-----------+--------------+
*/
SELECT RAND(), RAND();
/*
+------------------+------------------+
|      RAND()      |      RAND()      |
+------------------+------------------+ 
| 0.12090325459922 | 0.83369727882901 |
+------------------+------------------+
*/
SELECT ROUND(1.1), ROUND(1.1,2), ROUND(1,2);
/*
+------------+--------------+------------+
| ROUND(1.1) | ROUND(1.1,2) | ROUND(1,2) |
+------------+--------------+------------+
|     1      |     1.10     |    1.00    | 
+------------+--------------+------------+
*/
SELECT ROUND(1.235,2), TRUNCATE(1.235,2);
/*
+----------------+-------------------+
| ROUND(1.235,2) | TRUNCATE(1.235,2) |
+----------------+-------------------+
|      1.24      |       1.23        | 
+----------------+-------------------+
```
`MOD(x，y)`函数：返回`x/y`的模。 和`x%y`的结果相同，模数和被模数任何一个为`NULL`结果都为`NULL`。

`ROUND(x,y)`函数返回参数`x`的四舍五入的有`y`位小数的值。如果是整数，将会保留`y`位数量的 0；如果不写`y`，则默认`y`为 0，即将`x`四舍五入后取整。

`TRUNCATE`和`ROUND`的区别在于`TRUNCATE`仅仅是截断，而不进行四舍五入。

# 日期和时间函数

| 函数 | 说明 |
| :--: | :--: |
| CURDATE()() | 返回当前日期 |
| CURTIME() | 返回当前时间 |
| NOW() | 返回当前日期和时间 |
| UNIX_TIMESTAMP(date) | 返回日期 date 的 UNIX 时间戳 |
| FROM_UNIXTIME | 返回 UNIX 时间戳的日期值 |
| WEEK(date) | 返回日期 date 为一年中的第几周 |
| YEAR(date) | 返回日期 date 的年份 |
| HOUR(time) | 返回 time 的小时值 |
| MINUTE(time) | 返回 time 的分钟值 |
| MONTHNAME(date) | 返回 date 的月份名 |
| DATE_FORMAT(date,fmt) | 返回按字符串 fmt 格式化日期 date 值 |
| DATE_ADD(date,INTERVAL expr type) | 返回一个日期或时间值加上一个时间间隔的时间值 |
| DATEDIFF(expr,expr2) | 返回起始时间 expr 和结束时间 expr2 之间的天数 |

需要注意的是 MySQL 使用的日期格式。无论你什么时候指定一个日期，日期必须为格式`yyyy-mm-dd`。因此，2005年9月1日，给出为`2005-09-01`。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性。

应该总是使用 4 位数字的年份，支持 2 位数字的年份，MySQL 处理`00-69`为`2000-2069`，处理`70-99`为`1970-1999`。虽然它们可能是打算要的年份，但使用完整的 4 位数字年份更可靠，因为 MySQL 不必做出任何假定。

因此，基本的日期比较应该很简单：
```sql
SELECT cust_id, order_num FROM orders WHERE order_date = '2005-09-01';
```
但是，使用`WHERE order_date = '2005-09-01'`可靠吗？`order_date`的数据类型为`datetime`。这种类型存储日期及时间值。样例表中的值全都具有时间值`00:00:00`，但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期（因此你不仅知道订单日期，还知道下订单当天的时间），怎么办？比如，存储的`order_date`值为`2005-09-01 11:30:05`，则`WHERE order_date = '2005-09-01'`失败。即使给出具有该日期的一行，也不会把它检索出来，因为`WHERE`匹配失败。

解决办法是指示 MySQL 仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用`Date()`函数。`Date(order_date)`指示 MySQL 仅提取列的日期部分，更可靠的`SELECT`语句为：
```sql
SELECT cust_id, order_num FROM orders WHERE Date(order_date) = '2005-09-01';
```
不过，还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法，其中之一如下所示：
```sql
SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
```
还有另外一种办法（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法）：
```sql
SELECT cust_id, order_num FROM orders WHERE Year(order_date) = 2005 AND Month(order_date) = 9;
```
# 聚集函数
聚集函数运行在行组上，计算和返回单个值的函数。

| 函数 | 说明 |
| :--: | :--: |
| AVG() | 返回某列的平均值 |
| COUNT() | 返回某列的行数 |
| MAX() | 返回某列的最大值 |
| MIN() | 返回某列的最小值 |
| SUM() | 返回某列值之和 |

## AVG()函数
`AVG()`通过对表中行数计数并计算特定列值之和，求得该列的平均值。`AVG()`可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。

下面的例子使用`AVG()`返回`products`表中所有产品的平均价格：
```sql
SELECT AVG(prod_price) AS avg_price FROM products;
```
`AVG()`也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格：
```sql
SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id = 1003;
```
`AVG()`函数忽略列值为`NULL`的行。
## COUNT()函数
`COUNT()`函数进行计数。可利用`COUNT()`确定表中行的数目或符合特定条件的行的数目。

`COUNT()`函数有两种使用方式：
* 使用`COUNT(*)`对表中行的数目进行计数，不管表列中包含的是空值（`NULL`）还是非空值。
* 使用`COUNT(column)`对特定列中具有值的行进行计数，忽略`NULL`值。

```sql
SELECT COUNT(*) AS num_cust FROM customers;
```
此例子中，利用`COUNT(*)`对所有行计数，不管行中各列有什么值。计数值在`num_cust`中返回。

下面的例子只对具有电子邮件地址的客户计数：
```sql
SELECT COUNT(cust_email) AS num_cust FROM customers;
```
如果指定列名，则指定列的值为空的行被`COUNT()`函数忽略，但如果`COUNT()`函数中用的是星号（*），则不忽略。
## MAX()函数
`MAX()`返回指定列中的最大值。`MAX()`要求指定列名。
```sql
SELECT MAX(prod_price) AS max_price FROM products;
```
虽然`MAX()`一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则`MAX()`返回最后一行。

`MAX()`函数忽略列值为`NULL`的行。
## MIN()函数
`MIN()`的功能正好与`MAX()`功能相反，它返回指定列的最小值。`MIN()`要求指定列名。
```sql
SELECT MIN(prod_price) AS min_price FROM products;
```
`MIN()`函数与`MAX()`函数类似，MySQL 允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则`MIN()`返回最前面的行。

`MIN()`函数忽略列值为`NULL`的行。
## SUM()函数
`SUM()`用来返回指定列值的和（总计）。

下面举一个例子，`orderitems`表包含订单中实际的物品，每个物品有相应的数量（`quantity`）。可如下检索所订购物品的总数（所有`quantity`值之和）：
```sql
SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 2005;
```
`SUM()`函数忽略列值为`NULL`的行。
## 聚集不同值
以上5个聚集函数都可以如下使用：
* 对所有的行执行计算，指定`ALL`参数或不给参数（因为`ALL`是默认行为）；
* 只包含不同的值，指定`DISTINCT`参数。

`ALL`参数不需要指定，因为它是默认行为。如果不指定`DISTINCT`，则假定为`ALL`。

下面的例子使用`AVG()`函数返回特定供应商提供的产品的平均价格。它与上面的`SELECT`语句相同，但使用了`DISTINCT`参数，因此平均值只考虑各个不同的价格：
```sql
SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003;
```
如果指定列名，则`DISTINCT`只能用于`COUNT()`。`DISTINCT`不能用于`COUNT(*)`，因此不允许使用`COUNT(DISTINCT)`，否则会产生错误。类似地，`DISTINCT`必须使用列名，不能用于计算或表达式。

虽然`DISTINCT`从技术上可用于`MIN()`和`MAX()`，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。
## 组合聚集函数
`SELECT`语句可根据需要包含多个聚集函数。
```sql
SELECT COUNT(*) AS num_items,
       MIN(prod_price) AS price_min,
       MAX(prod_price) AS price_max,
       AVG(prod_price) AS price_avg
FROM products;
```
在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的 SQL 更易于理解和使用（以及将来容易排除故障）。
# 其他常用函数

| 函数 | 说明 |
| :--: | :--: |
| DATABASE() | 返回当前数据库名 |
| VERSION() | 返回当前数据库版本 |
| USER() | 返回当前登录用户名 |
| INET_ATON(IP) | 返回 IP 地址的数字表示 |
| INET_NTOA(num) | 返回数字代表的 IP 地址 |
| PASSWORD(str) | 返回字符串 str 的加密版本 |
| MD5() | 返回字符串 str 的 MD5 值 |

```sql
SELECT DATABASE();
/*
+------------+
| DATABASE() |
+------------+
|    test    |
+------------+
*/
SELECT VERSION();
/*
+-----------+
| VERSION() |
+-----------+
|   5.7.0   |
+-----------+
*/
SELECT USER();
SELECT INET_ATON('192.168.1.1');
SELECT INET_NTOA(3232235777);
SELECT PASSWORD('123456');
```