---
title: Docker入门
date: 2022-01-18 16:24:41
tags: [Docker]
categories: Docker
---


# 什么是 Docker
## Docker 开源项目
Docker 是基于 Go 语言实现的云开源项目，诞生于 2013 年初，最初发起者是 dotCloud 公司。

现在主流的 Linux 操作系统都已经支持 Docker。例如，Redhat RHEL 6.5/ CentOS 6.5 往上的操作系统、Ubuntu 14.04 操作系统，都已经默认带有 Docker 软件包。

Docker 的主要目标是“Build, Ship and Run Any App, Anywhere”，即通过对应用组件的封装（`Packaging`）、分发（`Distribution`）、部署（`Deployment`）、运行（`Runtime`）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个 Web 应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。

Docker 基于 Linux 的多项开源技术提供了高效、敏捷和轻量级的容器方案，并且支持在多种主流云平台（PaaS）和本地系统上部署。可以说 Docker 为应用的开发和部署提供了“一站式”的解决方案。
## Linux 容器技术
Docker 引擎的基础是 Linux 容器（Linux Containers，LXC）技术。LXC 项目借鉴了前人成熟的容器设计理念，并基于一系列新的内核特性实现了更具扩展性的虚拟化容器方案。更加关键的是，LXC 被集成到了主流 Linux 内核中，进而成为 Linux 系统轻量级容器技术的事实标准。
## 从 Linux 容器到 Docker
在 LXC 的基础上，Docker 进一步优化了容器的使用体验。Docker 提供了各种容器管理工具（如分发、版本、移植等）让用户无需关注底层的操作，可以简单明了地管理和使用容器。用户操作 Docker 容器就像操作一个轻量级的虚拟机那样简单。

可以简单地将 Docker 容器理解为一种沙盒（`Sandbox`）。每个容器内运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分快速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。
# 为什么要使用 Docker
## Docker 容器虚拟化的好处
现在开发者需要能方便地创建运行在云平台上的应用，也就是说应用必须能够脱离底层机器，而且同时必须是“任何时间任何地点”可获取的。因此，开发者们需要一种创建分布式应用程序的方式，这也是 Docker 所能够提供的。

举个简单的应用场景的例子。假设用户试图基于最常见的 LAMP（Linux + Apache + MySQL + PHP）组合来运维一个网站。按照传统的做法，首先，需要安装 Apache、MySQL 和 PHP 以及它们各自运行所依赖的环境；之后分别对它们进行配置（包括创建合适的用户、配置参数等）；经过大量的操作后，还需要进行功能测试，看是否工作正常；如果不正常，则意味着更多的时间代价和不可控的风险。可以想象，如果再加上更多的应用，事情会变得更加难以处理。

更为可怕的是，一旦需要服务器迁移（例如从阿里云迁移到腾讯云），往往需要重新部署和调试。这些琐碎而无趣的“体力活”，极大地降低了工作效率。而 Docker 提供了一种更为聪明的方式，通过容器来打包应用，意味着迁移只需要在新的服务器上启动需要的容器就可以了。这无疑将节约大量的宝贵时间，并降低部署过程出现问题的风险。
## Docker 在开发和运维中的优势
对开发和运维（DevOps）人员来说，可能最梦寐以求的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。而 Docker 恰恰是可以实现这一终极目标的瑞士军刀。

具体说来，Docker 在开发和运维过程中，具有如下几个方面的优势。
* 更快速的交付和部署。使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用相同环境来部署代码。Docker 可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，各个步骤都有明确的配置和操作，整个过程全程可见，使团队更容易理解应用的创建和工作过程。
* 更高效的资源利用。Docker 容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager，VMM，以及 Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。
* 更轻松的迁移和扩展。Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性让用户可以在不同平台之间轻松地迁移应用。
* 更简单的更新管理。使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式进行分发和更新，从而实现自动化并且高效的容器管理。

## Docker 与虚拟机比较
作为一种轻量级的虚拟化方式，Docker 在运行应用上跟传统的虚拟机方式相比具有显著优势：
* Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。
* Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个 Docker 容器。
* Docker 通过类似 Git 的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。
* Docker 通过 Dockerfile 配置文件来支持灵活的自动化创建和部署机制，提高工作效率。

Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启动 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离的容器，并将应用放到容器内即可。

当然，在隔离性方面，传统的虚拟机方式多了一层额外的隔离。但这并不意味着 Docker 就不安全。Docker 利用 Linux 系统上的多种防护机制实现了严格可靠的隔离。

下表总结了使用 Docker 容器技术与传统虚拟机技术的特性比较。

| 特性       | 容器           | 虚拟机 |
| :--: | :--: | :--: |
| 启动速度   | 秒级            | 分钟级 |
| 硬盘使用   | 一般为 MB       | 一般为 GB |
| 性能       | 接近原生       | 弱于 |
| 系统支持量 | 单机支持上千个容器 |  一般几十个 |
| 隔离性     | 安全隔离       | 完全隔离 |

# 虚拟化与 Docker
虚拟化技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（Computing Virtualization），或通常说的服务器虚拟化。维基百科上的定义如下：

在计算机技术中，虚拟化（`Virtualization`）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。

可见，虚拟化的核心是对资源进行抽象，目标往往是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，同时带来降低成本、方便管理和容错容灾等好处。
从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。其中，真正意义上的基于硬件的虚拟化技术不多见，少数如网卡中的单根多 IO 虚拟化（Single Root I/O Virtualization and Sharing Specification，SR-IOV）等技术，也超出了本书的讨论范畴。

基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（通常说的虚拟机技术即属于这个范畴）。其中，前者一般指的是一些模拟设备或 Wine 这样的软件。后者又可以细分为如下几个子类：
* 完全虚拟化。虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无需进行修改。例如 VMware Workstation、VirtualBox、QEMU 等。
* 硬件辅助虚拟化。利用硬件（主要是 CPU）辅助支持（目前 x86 体系结构上可用的硬件辅助虚拟化技术包括 Intel-VT 和 AMD-V）处理敏感指令来实现完全虚拟化的功能，客户操作系统无需修改，例如 VMware Workstation、Xen、KVM。
* 部分虚拟化。只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。现在有些虚拟化技术的早期版本仅支持部分虚拟化。
* 超虚拟化（Paravirtualization）。部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改，例如早期的 Xen。
* 操作系统级虚拟化。内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关技术即在这个范畴。

可见，Docker 以及其他容器技术都属于操作系统的虚拟化这个范畴。

Docker 虚拟化方式之所以拥有众多优势，这跟操作系统的虚拟化自身的特点是分不开的。

{% asset_img 1.png Docker 和传统的虚拟机方式的不同之处 %}

传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。

Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。
# 核心概念
## Docker 镜像
Docker 镜像（Image）类似于虚拟机镜像，可以将它理解为一个面向 Docker 引擎的只读模板，包含了文件系统。

例如：一个镜像可以只包含一个完整的 Ubuntu 操作系统环境，可以把它称为一个 Ubuntu 镜像。镜像也可以安装了 Apache 应用程序（或用户需要的其他软件），可以把它称为一个 Apache 镜像。

镜像是创建 Docker 容器的基础。通过版本管理和增量的文件系统，Docker 提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。
## Docker 容器
Docker 容器（`Container`）类似于一个轻量级的沙箱，Docker 利用容器来运行和隔离应用。

容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。

可以把容器看做一个简易版的 Linux 系统环境（这包括`root`用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。

镜像自身是只读的。容器从镜像启动的时候，Docker 会在镜像的最上层创建一个可写层，镜像本身将保持不变。
## Docker 仓库
Docker 仓库（Repository）类似于代码仓库，是 Docker 集中存放镜像文件的场所。

有时候会看到有资料将 Docker 仓库和注册服务器（Registry）混为一谈，并不严格区分。实际上，注册服务器是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放 Ubuntu 操作系统镜像的仓库，称为 Ubuntu 仓库，其中可能包括 14.04、12.04 等不同版本的镜像。仓库注册服务器的示例如图所示。

{% asset_img 2.png 仓库和注册服务器 %}

根据所存储的镜像公开分享与否，Docker 仓库可以分为公开仓库和私有仓库两种形式。

当然，用户如果不希望公开分享自己的镜像文件，Docker 也支持用户在本地网络内创建一个只能自己访问的私有仓库。

当用户创建了自己的镜像之后就可以使用`push`命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上`pull`下来就可以了。