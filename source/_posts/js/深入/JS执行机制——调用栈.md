---
title: JS执行机制——调用栈
date: 2019-11-04 17:08:05
tags: [javascript, JS执行机制]
categories: [javascript, JS执行机制]
---


当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。

那么哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文？一般说来，有这么三种情况：
* 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
* 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
* 当使用`eval`函数的时候，`eval`的代码也会被编译，并创建执行上下文。

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此要理解调用栈，要先弄明白函数调用和栈结构。
# 什么是函数调用
函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。
```js
var a = 2
function add() {
  var b = 10
  return  a + b
}
add()
```
我们利用这段简单的代码来解释下函数调用的过程。

在执行到函数`add()`之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量：

{% asset_img img2.png 全局执行上下文 %}

从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。

执行上下文准备好之后，便开始执行全局代码，当执行到`add`这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：
* 首先，从全局执行上下文中，取出`add`函数代码。
* 其次，对`add`函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。
* 最后，执行代码，输出结果。

完整流程你可以参考下图：

{% asset_img img3.png 函数调用过程 %}

就这样，当执行到`add`函数的时候，我们就有了两个执行上下文了——全局执行上下文和`add`函数的执行上下文。

也就是说在执行 JavaScript 时，可能会存在多个执行上下文，JavaScript 引擎通过一种叫栈的数据结构来管理这些执行上下文。
# 什么是栈
关于栈，你可以结合这么一个贴切的例子来理解，一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个栈容器，车子开进单行线的操作叫做入栈，车子倒出去的操作叫做出栈。

在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。

所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出的特点。

{% asset_img img4.png 栈示意图 %}

# 什么是 JavaScript 的调用栈
JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。
```js
var a = 2
function add(b, c) {
  return b + c
}
function addAll(b, c) {
  var d = 10
  result = add(b, c)
  return a + result + d
}
addAll(3, 6)
```
下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。
#### 第一步，创建全局上下文，并将其压入栈底。
{% asset_img img5.png 全局执行上下文压栈 %}

从图中你也可以看出，变量`a`、函数`add`和`addAll`都保存到了全局上下文的变量环境对象中。

全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行`a=2`的赋值操作，执行该语句会将全局上下文变量环境中`a`的值设置为 2。设置后的全局上下文的状态如下图所示：

{% asset_img img6.png 赋值操作改变执行上下文中的值 %}

#### 第二步是调用 addAll 函数。
当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：

{% asset_img img7.png 执行 addAll 函数时的调用栈 %}

`addAll`函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是`d=10`的赋值操作，执行语句会将`addAll`函数执行上下文中的`d`由`undefined`变成了 10。

然后接着往下执行。
#### 第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。

{% asset_img img8.png 执行 add 函数时的调用栈 %}

当`add`函数返回时，该函数的执行上下文就会从栈顶弹出，并将`result`的值设置为`add`函数的返回值，也就是 9。如下图所示：

{% asset_img img9.png add 函数执行结束时的调用栈 %}

紧接着`addAll`执行最后一个相加操作后并返回，`addAll`的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：

{% asset_img img10.png addAll 函数执行结束时的调用栈 %}

至此，整个 JavaScript 流程执行结束了。

现在你应该知道了调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。
# 在开发中，如何利用好调用栈
## 1. 如何利用浏览器查看调用栈的信息
当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。

这么说可能有点抽象，这里我们拿上面的那段代码做个演示，打开开发者工具，点击`Source`标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到`add`函数时，执行流程就暂停了，这时可以通过右边`call stack`来查看当前的调用栈的情况，如下图：

{% asset_img img11.png addAll 查看函数调用关系 %}

从图中可以看出，右边的`call stack`下面显示出来了函数的调用关系：栈的最底部是`anonymous`，也就是全局的函数入口；中间是`addAll`函数；顶部是`add`函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。

除了通过断点来查看调用栈，你还可以使用`console.trace()`来输出当前的函数调用关系，比如在示例代码中的`add`函数里面加上了`console.trace()`，你就可以看到控制台输出的结果，如下图：

{% asset_img img12.png 使用 trace 函数输出当前调用栈信息 %}

## 2. 栈溢出（Stack Overflow）
现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。

特别是在写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：
```js
function division(a, b) {
  return division(a, b)
}
console.log(division(1, 2))
```
当执行时，就会抛出栈溢出错误，如下图：

{% asset_img img13.png 使用 trace 函数输出当前调用栈信息 %}

从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（`Maximum call stack size exceeded`）。

那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数`division`，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。

理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。
# 总结
* 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
* 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
* 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
* 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。