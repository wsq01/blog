


# RIP 缺陷
提及 OSFP 时，还得先从 RIP 说起。

RIP 以跳数来计算到达目的网络的最优路径，在实际应用时并不合适，以网络带宽和链路时延来衡量网络质量会更合理。

{% asset_img 1.png %}

RIP 支持的最大跳数是 16，无法用于搭建大规模的网络。

{% asset_img 2.png %}

RIP 的收敛速度慢，RIP 会对不可达路由的信息更新进行抑制，原路由失效，新路由要等到抑制时间结束后，才能更新。

{% asset_img 3.png %}

RIP 的更新周期长，一个路由器突然离线，其它路由器要很长时间才能发现。

RIP 使用广播发送全部路由信息，网络规模越大，路由信息占用的网络资源也越大。

{% asset_img 4.png %}

因此，RIP 路由并不适合大规模的网络，而 OSPF 协议解决了这些问题，得到了广泛的使用。
# OSPF 原理
OSPF，是`Open Shortest Path First`的缩写，译为开放最短路径优先。OSPF 是基于链路状态（`Link State`）的自治系统内部路由协议，用来替代 RIP 协议，通用的是 OSPFv2。

{% asset_img 5.png %}

与距离矢量协议不同，链路状态协议使用最短路径优先算法（`Shortest Path First，SPF`）计算和选择路由。这类路由协议关系网络链路或接口的状态，比如 up 、down 、IP 地址、掩码、带宽、利用率和时延等。每台路由器将已知的链路状态向其它路由器通告，让网络上每台路由器对网络结构有相同的了解。然后，路由器以此为依据，使用 SPF 算法计算和选择路由。

{% asset_img 6.png %}

OSPF 协议使用组播发送协议包，节约资源，又减少对其它网络设备的干扰。

OSPF 将协议包封装在 IP 包中，协议号 89。由于 IP 协议是无连接的，OSPF 定义了一些机制保证协议包安全可靠的传输。

{% asset_img 7.png %}

总之，OSPF 协议比 RIP 有更大的扩展、快速收敛和安全可靠等特性，采用路由增量更新保证路由同步，减少对网络资源的浪费。

## OSPF 协议简介
{% asset_img 8.png %}

OSPF 协议有四个主要过程：

寻找邻居

OSPF 协议启动后，先寻找网络中的邻居（`Neighbor`），也就是通过`Hello`报文确认可以双向通信。

{% asset_img 9.png %}

建立邻接关系

一部分路由器形成邻居关系后，就开始进行建立邻接关系（`Adjacency`）。建立了邻居关系的路由器才能互相传递链路状态信息。

{% asset_img 10.png %}

链路状态信息同步

建立邻接关系的 OSPF 路由器在网络中交互 LSA（链路状态通告），最后形成包含网络完整链路状态信息的 LSDB（链路状态数据库）。

{% asset_img 11.png %}

计算路由

LSDB 同步完成后，OSPF 区域内的每个路由器对网络结构有相同的认识，邻居路由器之间形成完全的邻接关系。然后，每台路由器根据 LSDB 的信息使用 SPF（最短路径优先）算法独立计算出路由。

{% asset_img 12.png %}

## OSPF 协议过程
将 OSPF 的四个过程展开来讲，就是一个个邻居状态的切换，不同的邻居状态有不同的行为。

{% asset_img 13.png %}

Down（失效）
OSPF 邻居的初始状态，表示接口没有收到邻居发来的`Hello`报文。

Init（初始）
收到邻居发送的`Hello`报文，但是报文内没有自己的`Router-ID`，邻居状态就是`Init`。这个状态表示，直连链路上有一个 OSPF 路由器，但是还未确认双向通信。接下来，路由器会把对方的`Router-ID`添加到发送的`Hello`报文中。

{% asset_img 14.png %}

## 什么是 Router-ID ？
`Router-ID`用于标识 OSPF 路由器，是一个 32 位的数值，跟 IPv4 地址格式一样。连续的 OSPF 路由器组成的网络叫做 OSPF 域，域内`Router-ID`必须唯一，也就是在同一个域内不允许出现两台相同`Router-ID`的路由器。`Router-ID`可以手动设置，也可以自动生成，常见的做法是把设备的`Router-ID`指定为设备的`Loopback`接口的 IP 地址。

Attempt（尝试）
只在 NBMA 网络中出现。当路由器的 NBMA 接口启动后，邻居状态从`Down`切换到`Attempt`。这种状态下，路由器周期性的向邻居发送`Hello`报文，但是未收到邻居的有效`Hello`报文。当路由器收到邻居发送的没有自己`Router-ID`的`Hello`报文后，就将邻居状态切换到`Init`。

{% asset_img 15.png %}

## 什么是 NBMA ？
NBMA 类型的网络已经看不到了，它允许多台路由器接入，但是没有广播能力，无法使用组播或广播，只能配置成单播发送 OSPF 报文。帧中继、X.25 都是这类网络。

2-Way（双向通信）
路由器收到邻居的`Hello`报文，报文里有自己的`Router-ID`时，状态切换成`2-Way`，表示两个路由器形成了可以双向通信的邻居关系。

{% asset_img 16.png %}

选举 DR 和 BDR
如果路由器是在一个 MA 网络，邻居状态在 2-Way 后，会进行 DR 和 BDR 选举。
## 什么是 MA 网络？
MA 网络，即多路访问网络，是在同一个共享介质中连接多个设备的网络。网络中的任意两台设备都能直接进行二层通信。MA 网络有两种，一种是 BMA 网络，即广播型多路访问网络，比如以太网，典型场景就是一台以太网交换机连接着多台路由器，如果有一个广播数据发出来，整个网络中的路由器都能收到。另一种是 NBMA 网络，即非广播型多路访问网络，比如帧中继，只是帧中继不支持广播。

在 MA 网络中，n 台路由器都两两建立邻接关系，那么就有`n(n-1)/2`个邻接关系，会消耗大量的路由器资源，增加网络中 LSA 的泛洪数量。为了优化邻接关系数量，减少不必要的协议流量，OSPF 会在每一个 MA 网络中选举一个 DR（指定路由器）和一个 BDR（备用指定路由器）。

既不是 DR 也不是 BDR 的路由器叫做 DROther ，MA网络中所有 DROther 只和 DR 及 BDR 建立 OSPF 邻接关系，BDR 也和 DR 建立邻接关系，DROther 之间只停留在 2-Way 状态。这样，就有 2(n-2)+1 个邻接关系，数量得到优化。

{% asset_img 17.png %}

DR 会侦听网络中的拓扑变化信息，并将变更信息通知给其它路由器。BDR 会监控 DR 状态，当 DR 发生故障时就接替它的工作。

DR、BDR 的选举通过`Hello`报文实现，发生在`2-Way`状态之后。`Hello`报文有路由器接口的 DR 优先级，取值范围是`0~255`，默认值为 1，DR 优先级为 0 的接口没有 DR 和 BDR 的选举资格。

当接口激活 OSPF 后，它会查看网络中是否存在 DR，如果有就使用已经存在的 DR，也就是 DR 不可抢占，否则选择最高优先级的路由器成为 DR，当优先级相等时，选择`Router-ID`最大的路由器成为 DR。之后还会进行 BDR 的选举，选举过程与 DR 类似。

需要注意的是，DR 和 BDR 是一个接口级别的概念。某台路由器是 DR，这种说法不准确，严谨的说法是：某台路由器的某个接口在这个 MA 网络中是 DR。

{% asset_img 18.png %}

在一个 MA 网络中，DR 要确保网络中的所有路由器有相同的 LSDB，也就是确保 LSDB 同步。DR 使用组播地址`224.0.0.5`向网络中发送 LSU 报文，所有 OSPF 路由器都会侦听这个组播地址，并同步自己的 LSDB。而 DROther 感知到拓扑变化时，向`224.0.0.6`发送 LSU 报文通告这个变化，DR 和 BDR 会侦听这个组播地址。

{% asset_img 19.png %}

ExSart（交换开始）
接来下，路由器会进入 ExStart 状态，发送空的 DD 报文，用于协商`Master/Slave`，Router-ID 最大的路由器成为 Master 路由器，DD 报文的序列号由 Master 路由器决定。协商`Master/Slave`的报文是空的、不携带 LSA 头部的 DD 报文，这时报文的 I 位被设置成 1。

Exchange（交换）
接下来，路由器进入`Exchange`状态，向邻居发送描述自己 LSDB 的 DD 报文，DD 报文中包含 LSA 头部。DD 报文逐个发送，每个报文中都有 DD 序列号，DD 序列号由 Master 路由器决定，序列号在 DD 报文的交互过程中递增，确保交互过程的有序性和可靠性。

## 什么是 DD 报文？
DD 报文用于描述 LSDB，携带 LSDB 中 LSA 的头部数据，而非完整的 LSA 内容。在路由器邻接关系的建立过程中，先用空的 DD 报文协商`Master/Slave`，然后用 DD 报文描述各自的 LSDB，这种 DD 报文包含 LSDB 里的 LSA 头部。路由器可以使用多个 DD 报文来描述 LSDB，为了保证 DD 报文传输的顺序和可靠，Master 路由器使用序列号字段递增的方式，主导整个 LSDB 描述过程。

{% asset_img 20.png %}

Loading（加载）
接下来，路由器进入 Loading 状态，路由器向邻居发送 LSR 请求 LSA 的完整信息。邻居使用 LSU 进行回应，LSU 报文里有 LSA 的完整信息。在收到 LSU 报文后，路由器需要发送 LSAck 对 LSA 进行确认。

Full（完整）
当接口上需要请求的 LSA 列表为空时，表示路由器已经完成了和邻居的 LSDB 同步，没有再需要请求的 LSA 了，这时邻居的状态就是`Full`。

路由计算
接下来，路由器开始计算路由。先评估一台路由器到另一台路由器需要的度量值。OSPF 协议是根据路由器的每一个接口的度量值决定最短路径的。一条路由的开销是指到达目的网络的路径上所有路由器接口的度量值总和。

度量值和接口带宽有关，路由器的接口度量值是根据公式 100/带宽（Mbps）计算出来的，它作为评估路由器之间网络资源的参考值。另外也可以通过命令手工指定路由器的度量值。
## 什么是度量值？
每种路由协议对度量值的定义是不同的，OSPF 使用 Cost（开销）作为路由度量值，Cost 值越小，则路径（路由）越优。每一个激活 OSPF 的接口都有一个接口的`Cost`值，值等于 100/接口带宽 Mbit/s，计算结果取整数部分，当结果小于 1 时，值取 1。这个值也可以人为修改，修改值会直接影响`Cost`值的计算，从而影响网络中 OSPF 路由的选择。

同步 OSPF 区域内每台路由器的 LSDB，路由器通过交互 LSA 实现 LSDB 的同步。LSA 不但携带了网络连接状况信息，而且携带各接口的`Cost`信息。

由于一条 LSA 是对一台路由器或一个网段拓扑结构的描述，整个 LSDB 就形成了对整个网络的拓扑结构的描述。所有路由器得到一张完全相同的图。

{% asset_img 21.png %}

使用 SPF（最短路径优先算法）计算出路由。OSPF 路由器用 SPF 算法以自己为根节点，计算出一棵最短路径树。这棵树上，由根到各个节点的累计开销最小，也就是从根到各个节点的路径都是最优的，这样就获得了由根去往各个节点的路由。计算完成后，路由器将路由加入到 OSPF 路由表。当 SPF 算法发现有两条到达目的网络的路由的`Cost`值相同，会将这两条路由都加入到 OSPF 路由表中，形成等价路由。

{% asset_img 22.png %}

