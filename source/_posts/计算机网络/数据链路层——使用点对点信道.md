

两台主机通过互联网进行通信时数据链路层所处的地位。
{% asset_img img1.png %}
{% asset_img img2.png %}
{% asset_img img3.png %}
{% asset_img img4.png %}
数据链路层使用的信道：
{% asset_img img5.png %}
# 使用点对点信道的数据链路层
## 数据链路和帧
链路(`link`)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。

在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见一条链路只是一条通路的一个组成部分。

数据链路(`data link`)除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。

现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。

一般的适配器都包括了数据链路层和物理层这两层的功能。

也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。

物理链路就是上面所说的链路。

逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。

早期的数据通信协议曾叫做通信规程(`procedure`)。因此在数据链路层，规程和协议是同义语。

点对点信道的数据链路层的协议数据单元叫帧。数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。

为了把主要精力放在点对点信道的数据链路层协议上，可以采用三层模型。在这种三层模型中，不管在哪一段链路上的通信(主机和路由器之间或两个路由器之 
间)，我们都看成是结点和结点的通信，而每个结点只有下三层——网络层、数据链路层和物理层。

{% asset_img img6.png %}

点对点信道的数据链路层在进行通信时的主要步骤如下：
1. 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
2. 结点A把封装好的帧发送给结点B的数据链路层。
3. 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上 面的网络层；否则丢弃这个帧。

数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。
## 三个基本问题
数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输、差错控制。

### 封装成帧
封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。

一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。

首部和尾部的一个重要作用就是进行帧定界。此外，首部和尾部还包括许多必要的控制信息。

在发送帧时，是从帧首部开始发送的。

{% asset_img img7.png %}

### 用控制字符进行帧定界的方法举例
当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。

控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。

SOH和EOT都是控制字符的名称。它们的十六进制编码分别是01(二进制是00000001)和04(二进制是00000100)。

{% asset_img img8.png %}

### 透明传输
如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。

{% asset_img img9.png %}

“在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。

解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)。
发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。
接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。
如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 

{% asset_img img10.png %}

### 差错检测
在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。这就叫做比特差错。比特差错是传输差错中的一种。

{% asset_img img11.png %}

在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。
误码率与信噪比有很大的关系。
为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 
在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。

### 循环冗余检验的原理
在发送端，先把数据划分为组。假定每组 k 个比特。

在每组 M 后面再添加供差错检测用的 n 位冗余码，然后一起发送出去。

{% asset_img img12.png %}

冗余码的计算：
* 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。
* 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 
* 将余数 R 作为冗余码拼接在数据 M 后面，一起发送出去。

{% asset_img img13.png %}

接收端对收到的每一帧进行 CRC 检验
(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。
(2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。
但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。
只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。

冗余码的计算举例 
现在 k = 6, M = 101001。
设 n = 3, 除数 P = 1101，
被除数是 2nM = 101001000。 
模 2 运算的结果是：商 Q = 110101，余数 R = 001。
把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R，即：101001001，共 (k + n) 位。

循环冗余检验的原理说明
{% asset_img img14.png %}

帧检验序列 FCS
在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。
循环冗余检验 CRC 和帧检验序列 FCS 并不等同。
CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。
FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 

应当注意
仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)。
“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。
也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。
单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。
应当明确，“无比特差错”与“无传输差错”是不同的概念。
在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。
要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 
数据链路层协议都不是可靠传输的协议。
