---
title: 运输层——TCP的运输连接管理
date: 2020-10-17 11:51:33
tags: 计算机网络
categories: 计算机网络
---


TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。

TCP 连接有三个阶段：连接建立、数据传送、连接释放。

TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。

TCP 连接建立过程中要解决的三个问题：
1. 要使每一方能够确知对方的存在。
2. 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户，被动等待建立连接的应用进程叫服务器。
# TCP的连接建立
TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。

{% asset_img img1.png 用三次握手建立 TCP 连接的各状态 %}

假定主机 A 运行的是 TCP 客户程序，B 运行 TCP 服务器程序。最初两端的 TCP 进程都处于`CLOSED`（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。注意，A 主动打开连接，B 被动打开连接。

B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于`LISTEN`（收听）状态，等待客户的连接请求。

A 的 TCP 客户进程也是首先创建传输控制块 TCB，然后向 B 发出连接请求报文段，这时，首部中的同部位`SYN = 1`，同时选择一个初始序号`seq = x`。TCP 规定`SYN`报文段（即`SYN = 1`的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入`SYN-SENT`（同步已发送）状态。

B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中，`SYN = 1, ACK = 1`，确认号是`ack = x + 1`，同时也为自己选择一个初始序号`seq = y`。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务器进程进入`SYN-RCVD`（同步收到）状态。

TCP 客户进程收到 B 的确认后，还要向 B 给出确认。`ACK = 1, ack = y + 1`，而自己的序号`seq = x + 1`。TCP 规定，`ACK`报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是`seq = x + 1`。这时 TCP 连接已经建立，A 进入`ESTABLISHED`（已建立连接）状态。

当 B 收到 A 的确认后，也进入`ESTABLISHED`状态。

为什么 A 还要发一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。

所谓已失效的连接请求报文是这样产生的。考虑一种正常情况，A 发出连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发了两个连接请求报文段。其中第一个丢失，第二个到达 B。没有“已失效的连接请求报文段”。

现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据，B 的许多资源就这样白白浪费了。

采用三次握手就可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认，B 收不到确认就知道 A 并没有要求建立连接。
# TCP的连接释放
TCP 连接释放过程是四报文握手。

{% asset_img img2.png %}

数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于`ESTABLISHED`状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的`FIN`置1，其序号`seq = u`，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入`FIN-WAIT-1`（终止等待1）状态，等待 B 的确认。TCP 规定，`FIN`报文段即使不携带数据也消耗掉一个序号。

B 收到连接释放报文段后立即发出确认，确认号是`ack = u + 1`，而这个报文段自己的序号是`v`，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 进入`CLOSE-WAIT`（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭。这个状态可能会持续一些时间。

A 收到来自 B 的确认后，就进入`FIN-WAIT-2`（终止等待2）状态，等待 B 发出的连接释放报文段。

若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使`FIN = 1`。现假定 B 的序号为`w`（半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号`ack = u + 1`。这时 B 就进入`LAST-ACK`（最后确认）状态，等待 A 的确认。

A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中，`ACK = 1, ack = w + 1`，而自己的序号是`seq = u + 1`。然后进入到`TIME-WAIT`（时间等待）状态。现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL 后，A 才进入到`CLOSED`状态。时间 MSL 叫最长报文段寿命(`Maximum Segment Lifetime`)。当 A 撤销相应的传输控制块 TCB 后，就结束了这次 TCP 连接。

B 只要收到了 A 的确认，就进入`CLOSED`状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早。
## A 必须等待 2MSL 的时间
第一，为了保证 A 发送的最后一个`ACK`报文段能够到达 B。

第二，防止 “已失效的连接请求报文段”出现在本连接中。
## 保活计时器
除时间等待计时器外，TCP还设有一个保活计时器(`keepalive timer`)，用来防止在 TCP 连接出现长时期的空闲。

设想有这样的情况：客户己主动与服务器建立了 TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器。

保活计时器通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 
# TCP的有限状态机

{% asset_img img3.png TCP 的有限状态机 %}

图中每一个方框都是 TCP 可能具有的状态。

每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。

箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。

图中有三种不同的箭头：
* 粗实线箭头表示对客户进程的正常变迁。
* 粗虚线箭头表示对服务器进程的正常变迁。
* 另一种细线箭头表示异常变迁。 