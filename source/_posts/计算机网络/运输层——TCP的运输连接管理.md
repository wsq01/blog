---
title: 运输层——TCP的运输连接管理
date: 2020-10-17 11:51:33
tags: 计算机网络
categories: 计算机网络
---


TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。

TCP 连接有三个阶段：连接建立、数据传送、连接释放。

TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。

TCP 连接建立过程中要解决的三个问题：
1. 要使每一方能够确知对方的存在。
2. 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户，被动等待建立连接的应用进程叫服务器。
# TCP的连接建立
TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。

{% asset_img img1.png 用三次握手建立 TCP 连接的各状态 %}

假定主机 A 运行的是 TCP 客户程序，B 运行 TCP 服务器程序。最初两端的 TCP 进程都处于`CLOSED`（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。注意，A 主动打开连接，B 被动打开连接。

B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于`LISTEN`（收听）状态，等待客户的连接请求。

A 的 TCP 客户进程也是首先创建传输控制块 TCB，然后向 B 发出连接请求报文段，这时，首部中的同部位`SYN = 1`，同时选择一个初始序号`seq = x`。TCP 规定`SYN`报文段（即`SYN = 1`的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入`SYN-SENT`（同步已发送）状态。

B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中，`SYN = 1, ACK = 1`，确认号是`ack = x + 1`，同时也为自己选择一个初始序号`seq = y`。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务器进程进入`SYN-RCVD`（同步收到）状态。

TCP 客户进程收到 B 的确认后，还要向 B 给出确认。`ACK = 1, ack = y + 1`，而自己的序号`seq = x + 1`。TCP 规定，`ACK`报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是`seq = x + 1`。这时 TCP 连接已经建立，A 进入`ESTABLISHED`（已建立连接）状态。

当 B 收到 A 的确认后，也进入`ESTABLISHED`状态。

从上⾯的过程可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的。

⼀旦完成三次握⼿，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。
## 为什么是三次握手？不是两次、四次？
三次握⼿的原因：
* 三次握⼿才可以阻止重复历史连接的初始化（主要原因）
* 三次握⼿才可以同步双方的初始序列号
* 三次握⼿才可以避免资源浪费

### 原因⼀：避免历史连接
简单来说，三次握⼿的⾸要原因是为了防止旧的重复连接初始化造成混乱。

网络环境是错综复杂的，往往并不是如我们期望的⼀样，先发送的数据包，就先到达⽬标主机，反而它很骚，可能会由于网络拥堵等乱七⼋糟的原因，会使得旧的数据包，先到达⽬标主机，那么这种情况下 TCP 三次握⼿是如何避免的呢？

{% asset_img 10.jpg %}

客户端连续发送多次 SYN 建立连接的报⽂，在网络拥堵情况下：
* ⼀个「旧 SYN 报⽂」比「最新的 SYN」 报⽂早到达了服务端；
* 那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端；
* 客户端收到后可以根据自身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送 RST 报⽂给服务端，表示中止这⼀次连接。

如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送方）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接：
* 如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中止历史连接；
* 如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双方就会成功建立连接；

所以，TCP 使用三次握⼿建立连接的最主要原因是防止历史连接初始化了连接。

### 原因⼆：同步双方初始序列号
TCP 协议的通信双方， 都必须维护⼀个序列号， 序列号是可靠传输的⼀个关键因素，它的作用： 
* 接收方可以去除重复的数据；
* 接收方可以根据数据包的序列号按序接收；
* 可以标识发送出去的数据包中， 哪些是已经被对方收到的；

可⻅，序列号在 TCP 连接中占据着⾮常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报⽂的时候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双方的初始序列号能被可靠的同步。

{% asset_img 12.jpg %}

四次握⼿其实也能够可靠的同步双方的初始化序号，但由于第⼆步和第三步可以优化成⼀步，所以就成了三次握⼿。

而两次握⼿只保证了⼀方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
### 原因三：避免资源浪费
如果只有两次握⼿，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报⽂，就会重新发送 SYN ，由于没有第三次握⼿，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建立⼀个连接，这会造成什么情况呢？

如果客户端的 SYN 阻塞了，重复发送多次 SYN 报⽂，那么服务器在收到请求后就会建立多个冗余的⽆效链接，造成不必要的资源浪费。

{% asset_img 13.jpg %}

即两次握⼿会造成消息滞留情况下，服务器重复接受⽆用的连接请求 SYN 报⽂，而造成重复分配资源。

### 小结
TCP 建立连接时，通过三次握⼿能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用两次握⼿和四次握⼿的原因：
* 两次握⼿：⽆法防止历史连接的建立，会造成双方资源的浪费，也⽆法可靠的同步双方序列号；
* 四次握⼿：三次握⼿就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

# TCP的连接释放
TCP 连接释放过程是四报文握手。

{% asset_img img2.png %}

数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于`ESTABLISHED`状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的`FIN`置1，其序号`seq = u`，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入`FIN-WAIT-1`（终止等待1）状态，等待 B 的确认。TCP 规定，`FIN`报文段即使不携带数据也消耗掉一个序号。

B 收到连接释放报文段后立即发出确认，确认号是`ack = u + 1`，而这个报文段自己的序号是`v`，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 进入`CLOSE-WAIT`（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭。这个状态可能会持续一些时间。

A 收到来自 B 的确认后，就进入`FIN-WAIT-2`（终止等待2）状态，等待 B 发出的连接释放报文段。

若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使`FIN = 1`。现假定 B 的序号为`w`（半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号`ack = u + 1`。这时 B 就进入`LAST-ACK`（最后确认）状态，等待 A 的确认。

A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中，`ACK = 1, ack = w + 1`，而自己的序号是`seq = u + 1`。然后进入到`TIME-WAIT`（时间等待）状态。现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL 后，A 才进入到`CLOSED`状态。时间 MSL 叫最长报文段寿命(`Maximum Segment Lifetime`)。当 A 撤销相应的传输控制块 TCB 后，就结束了这次 TCP 连接。

B 只要收到了 A 的确认，就进入`CLOSED`状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早。

需要注意是：主动关闭连接的，才有`TIME_WAIT`状态。
### 为什么挥手需要四次？
关闭连接时，客户端向服务端发送`FIN`时，仅仅表示客户端不再发送数据了但是还能接收数据。

服务器收到客户端的`FIN`报文时，先回一个`ACK`应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送`FIN`报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的`ACK`和`FIN`一般都会分开发送，从而比三次握手导致多了一次。
## A 必须等待 2MSL 的时间
第一，为了保证 A 发送的最后一个`ACK`报文段能够到达 B。这个`ACK`报文段有可能丢失，因而使处在`LAST-ACK`状态的 B 收不到对已发送的`FIN + ACK`报文段的确认。B 会超时重传这个`FIN + ACK`报文段，而 A 就能在 2MSL 时间内收到这个重传的`FIN + ACK`报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到`CLOSED`状态。如果 A 在`TIME_WAIT`状态不等待一段时间，而是在发送完`ACK`报文段后立即释放连接，那么就无法收到 B 重传的`FIN + ACK`报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入`CLOSED`状态。

第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个`ACK`报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

B 只要收到了 A 发岀的确认，就进入`CLOSED`状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早一些。
## 保活计时器
除时间等待计时器外，TCP还设有一个保活计时器(`keepalive timer`)，用来防止在 TCP 连接出现长时期的空闲。

设想有这样的情况：客户己主动与服务器建立了 TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器。

保活计时器通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 
# TCP的有限状态机

{% asset_img img3.png TCP 的有限状态机 %}

图中每一个方框都是 TCP 可能具有的状态。

每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。

箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。

图中有三种不同的箭头：
* 粗实线箭头表示对客户进程的正常变迁。
* 粗虚线箭头表示对服务器进程的正常变迁。
* 另一种细线箭头表示异常变迁。 