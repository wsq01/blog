---
title: JS 0.1 + 0.2的问题
date: 2018-03-09 22:21:41
tags: JS
categories: 
 - 前端
 - JS
---

# JavaScript中数字的存储机制
对于计算机而言，两个数字在相加时是以二进制形式进行的，在呈现结果时才转换成十进制。JS中的数字是用IEEE 754 双精度 64 位浮点数来存储的，它由64位组成，这64位由3部分组成，S：符号位，Exponent：指数域，Fraction：尾数域。

| | S(符号位) | P(阶码，指数位数) | M(尾数) | 表示公式 | 偏移量 |
| :- | :- | :- | :- | :- |
| 单精度浮点数 | 1(第31位) | 8(30到23位) | `(-1)^S*2(P-127)*1.M` | 127 |
| 双精度浮点数 | 1(第63位) | 11(62到52位) | `(-1)^S*2(P-127)*1.M` | 1023 |

# 数字表示
在计算机中，数字都是以二进制存储的，所以我们要先将 0.1 和 0.2 转化成二进制，对于十进制转二进制，整数部分除二取余，倒序排列，小数部分乘二取整，顺序排列。
```
如：0.7=（0.1 0110 0110...）B
0.7*2=1.4========取出整数部分1
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0

 // 0.1 转化为二进制
0.0 0011 0011 0011 0011...(0011无限循环）

// 0.2 转化为二进制
0.0011 0011 0011 0011 0011...(0011无限循环）
```
由于尾数只有52位，所以对于0.1和0.2转换后用IEEE 754 双精度64位浮点数来表示的二进制如下：
```
e = -4; m =1.1001100110011001100110011001100110011001100110011010 (52位)
e = -3; m =1.1001100110011001100110011001100110011001100110011010 (52位)
```
然后我们把它相加。
```
  e = -4; m = 1.1001100110011001100110011001100110011001100110011010 (52位)
+ e = -3; m = 1.1001100110011001100110011001100110011001100110011010 (52位)
---------------------------------------------------------------------------
相加时如果指数不一致，需要对齐，一般情况下是向右移，因为最右边的即使溢出了，损失的精度远远小于左边溢出。
  e = -3; m = 0.1100110011001100110011001100110011001100110011001101 
+ e = -3; m = 1.1001100110011001100110011001100110011001100110011010
---------------------------------------------------------------------------
  e = -3; m =10.0110011001100110011001100110011001100110011001100111
---------------------------------------------------------------------------
  e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)
---------------------------------------------------------------------------
= 0.010011001100110011001100110011001100110011001100110100
= 0.30000000000000004(十进制)
```
总结：我们可以看到，当十进制小数的二进制表示的有限数字超过 52 位时，在 JavaScript 里是不能精确存储的，这时候就存在舍入误差。