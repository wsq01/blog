


# 虚拟内存
单⽚机是没有操作系统的，所以每次写完代码，都需要借助⼯具把程序烧录进去，这样程序才能跑起来。另外，单⽚机的 CPU 是直接操作内存的「物理地址」。

{% asset_img 1.png %}

在这种情况下，要想在内存中同时运⾏两个程序是不可能的。如果第⼀个程序在 2000 的位置写⼊⼀个新的值，将会擦掉第⼆个程序存放在相同位置上的所有内容，所以同时运⾏两个程序是根本⾏不通的，这两个程序会⽴刻崩溃。

这⾥关键的问题是这两个程序都引⽤了绝对物理地址，⽽这正是我们最需要避免的。我们可以把进程所使⽤的地址「隔离」开来，即让操作系统为每个进程分配独⽴的⼀套「虚拟地址」，⼈⼈都有，⼤家⾃⼰玩⾃⼰的地址就⾏，互不⼲涉。但是有个前提每个进程都不能访问物理地址，⾄于虚拟地址最终怎么落到物理内存⾥，对进程来说是透明的，操作系统已经把这些都安排的明明⽩⽩了。

{% asset_img 2.png %}

操作系统会提供⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运⾏的时候，写⼊的是不同的物理地址，这样就不会冲突了。

于是，这⾥就引出了两种地址的概念：
* 我们程序所使⽤的内存地址叫做虚拟内存地址
* 实际存在硬件⾥⾯的空间地址叫物理内存地址

操作系统引⼊了虚拟内存，进程持有的虚拟地址会通过 CPU 芯⽚中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：

{% asset_img 3.png %}

操作系统是如何管理虚拟地址与物理地址之间的关系？

主要有两种⽅式，分别是内存分段和内存分⻚，分段是⽐较早提出的，我们先来看看内存分段。
# 内存分段
程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成，段选择⼦和段内偏移量。

{% asset_img 4.png %}

段选择⼦就保存在段寄存器⾥⾯。段选择⼦⾥⾯最重要的是段号，⽤作段表的索引。段表⾥⾯保存的是这个段的基地址、段的界限和特权等级等。
虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
在上⾯，知道了虚拟地址是通过段表与物理地址进⾏映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有⼀个项，在这⼀项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，
如下图

{% asset_img 5.png %}

如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500= 7500。
分段的办法很好，解决了程序本身不需要关⼼具体的物理内存地址的问题，但它也有⼀些不⾜之处：
第⼀个就是内存碎⽚的问题。
第⼆个就是内存交换的效率低的问题

我们来看看这样⼀个例⼦。假设有 1G 的物理内存，⽤户执⾏了多个程序，其中：
游戏占⽤了 512MB 内存
浏览器占⽤了 128MB 内存
⾳乐占⽤了 256 MB 内存。
这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。

如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开⼀个 200MB 的程序。

{% asset_img 6.jpg %}

# 内存分⻚
分段的好处就是能产⽣连续的内存空间，但是会出现内存碎⽚和内存交换的空间太⼤的问题。
要解决这些问题，那么就要想出能少出现⼀些内存碎⽚的办法。另外，当需要进⾏内存交换的时候，让需
要交换写⼊或者从磁盘装载的数据更少⼀点，这样就可以解决问题了。这个办法，也就是内存分⻚
（Paging）。
分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩。这样⼀个连续并且尺⼨固定的内存空间，
我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。
虚拟地址与物理地址之间通过⻚表来映射，如下图：