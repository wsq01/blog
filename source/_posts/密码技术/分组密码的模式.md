---
title: 分组密码的模式
date: 2020-12-14 16:57:13
tags: 密码技术
categories: 密码技术
---

AES 和 DES 都属于分组密码，它们只能加密固定长度的明文，如果要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的模式。

分组密码有很多种模式，如果模式的选择不恰当，就无法充分保证机密性。
# 分组密码的模式
## 分组密码与流密码
密码算法可以分为分组密码和流密码两种。

分组密码时每次只能处理特定长度的一块数据的一类密码算法。这里的一块就称为分组。此外，一个分组的比特数就称为分组长度。

例如 DES 和 3DES 的分组长度都是 64 比特，这些密码算法一次只能加密 64 比特的明文，并生成 64 比特的密文。

AES 的分组长度为 128 比特，因此 AES 一次可加密 128 比特的明文，并生成 128 比特的密文。

流密码是对数据流进行连续处理的一类密码算法。流密码中一般以 1 比特、8 比特或 32 比特等为单位进行加密和解密。

分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度。流密码是对一串数据流进行连续处理，因此需要保持内部状态。
## 模式
分组密码算法只能加密固定长度的分组，但我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式。

分组密码的主要模式有5种：
* ECB 模式：`Electronic CodeBook mode`（电子密码本模式）
* CBC 模式：`Cipher Block Chaining mode`（密码分组链接模式）
* CFB 模式：`Cipher FeedBack mode`（密文反馈模式）
* OFB 模式：`Output FeedBack mode`（输出反馈模式）
* CTR 模式：`CounTeR mode`（计数器模式）

## 明文分组和密文分组
明文分组是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。

密文分组是指使用分组密码算法将明文分组加密之后所生成的密文。

{% asset_img img1.png %}

# ECB 模式
ECB 模式由于存在弱点因此通常不会被使用。

在 ECB 模式中，将明文分组加密之后的结果将直接成为密文分组。

{% asset_img img2.png ECB 模式 %}

使用 ECB 模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组->密文分组”的对应表，因此 ECB 模式也称为电子密码本模式。

当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充(`padding`)。
## ECB 模式的特点
ECB 模式中，明文分组和密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此 ECB 模式是不安全的。
# CBC 模式
在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。

{% asset_img img3.png CBC 模式 %}

如果将一个分组的加密过程分离出来，我们就可以很容易的比较出 ECB 模式和 CBC 模式的区别：ECB 模式只进行了加密，CBC 模式在加密之前进行了一次 XOR。

{% asset_img img4.png ECB 模式 和 CBC 模式比较 %}

## 初始化向量
当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量(`Initialization Vector`)，通常缩写为`IV`。

一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。
## CBC模式的特点
明文分组在加密之前一定会与“前一个密文分组”进行 XOR 运算，因此，即便明文分组 1 和 2 的值是相等的，密文分组 1 和 2 的值也不一定是相等的。这样一来，ECB 模式的缺陷在 CBC 模式中就不存在了。

在 CBC 模式的加密过程中，无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组 3，则至少需要凑齐明文分组 1、2、3.

在 CBC 模式的解密过程中，现在假设 CBC 模式加密的密文分组中有一个分组损坏了，在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有两个分组受到数据损坏的影响。

{% asset_img img7.png %}

假设 CBC 模式的密文分组中有一些比特缺失了，那么即便只是缺失了 1 比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密了。

## 对CBC模式的攻击
假如主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（即将 1 变为 0，0 变为 1），则明文分组（解密后得到的明文分组）中相应的比特也会被反转。这是因为在 CBC 模式的解密过程中，第一个明文分组会和初始化向量进行 XOR 运算。

{% asset_img img8.png %}
{% asset_img img9.png %}

这样，攻击者就可以对初始化向量进行攻击。
## 填充提示攻击
填充提示攻击是一种利用分组密码中的填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充的数据进行少许改变。由于接收者（服务器）在无法正确解密时会返回一个错误信息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。这一攻击方式并不仅限于 CBC 模式，而是适用于所有需要进行分组填充的模式。
## 对初始化向量（IV）攻击
初始化向量`IV`必须使用不可预测的随机数
## CBC 模式的应用实例
SSL/TLS 就是使用 CBC 模式来确保通信的机密性的，如使用 CBC 模式三重 DES 的 3DES_EDE_CBC 以及 CBC 模式 256 比特 AES 的 AES_256_CBC等。
# CFB 模式
在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，指的就是返回输入端的意思。

{% asset_img img10.png %}

在 ECB 模式和 CBC 模式中，明文分组都是通过密码算法进行加密的，然而，在 CFB 模式中，明文分组并没有通过密码算法来直接进行加密。

{% asset_img img11.png CBC 模式与 CFB 模式的对比 %}

## 初始化向量
在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量来代替，这一点和 CBC 模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。
## CFB 模式与流密码
CFB 模式的结构与一次性密码本是非常相似的。一次性密码本是通过将明文与随机比特序列进行 XOR 运算来生成密文的。而 CFB 模式则是通过将明文分组与密码算法的输出进行 XOR 运算来生成密文分组的。在通过 XOR 来进行加密这一点上，两者是非常相似的。

在 CFB 模式中，密码算法的输出相当于一次性密码本中的随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此 CFB 模式不可能像一次性密码本那样具备理论上不可破译的性质。

CFB 模式中由密码算法所生成的比特序列称为密钥流。在 CFB 模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的种子。

在 CFB 模式中，明文数据可以被逐比特加密，因此我们可以将 CFB 模式看做是一种使用分组密码来实现流密码的方式。
## 对 CFB 模式的攻击
对 CFB 模式可以实施重放攻击。

有一天，发送者向接收者发送了一条消息，这条消息由 4 个密文分组组成。主动攻击者将该消息中的后 3 个密文分组保存了下来。转天，发送者又向接收者发送了内容不同的 4 个密文分组（假设发送者使用了相同的密钥）。攻击者用昨天保存下来的 3 个密文分组将今天发送的后 3 个密文分组进行了替换。

于是，当接收者解密时，4 个分组中就只有第一个可以解密成正确的明文分组，第二个会出错，而第三个和第四个则变成了被攻击者替换的内容。攻击者没有破解密码就成功的将以前的电文混入了新电文中。而第二个分组出错到底是通信错误还是被人攻击造成的，接收者是无法做出判断的。要做出这样的判断，需要使用消息认证码。

{% asset_img img12.png 对 CFB 进行重放攻击 %}

# OFB 模式
在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中。

OFB 模式并不是通过密码算法对明文直接进行加密的，而是通过将明文分组和密码算法的输出进行 XOR 来产生密文分组的。

{% asset_img img13.png %}
{% asset_img img14.png %}

## 初始化向量
和 CBC 模式、CFB 模式一样，OFB 模式也需要使用初始化向量(IV)。需要在每次加密时生成一个不同的随机比特序列用作初始化向量。
## CFB 模式与 OFB 模式对比
OFB 模式和 CFB 模式的区别仅仅在于密码算法的输入。

CFB 模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，因此有了密文反馈模式这个名字。

OFB 模式中，密码算法的输入是密码算法的前一个输出，也就是将输出反馈给密码算法，因此有了输出反馈模式这个名字。

如果将一个分组抽出来对 CFB 模式和 OFB 模式进行一个对比，就可以很容易看出它们之间的差异。

{% asset_img img15.png %}

由于 CFB 模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组 1 而先对明文分组 2 进行加密。

相对的，在 OFB 模式中，XOR 所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密文流进行 XOR 就可以了。和 AES 等密码算法相比，XOR 运算的速度非常快。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度看，生成密钥流的操作和进行 XOR 运算的操作是可以并行的。
# CTR 模式
CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。

CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列与明文分组进行 XOR 得到的。

{% asset_img img5.png %}

## 计数器的生成方法
每次加密都会生成一个不同的值(`nonce`)来作为计数器的初始值。当分组长度为 128 比特（16字节）时，计数器初始值可能是像下面这样的形式。

{% asset_img img6.png %}

其中前 8 个字节为`nonce`，这个值在每次加密时必须都是不同的。后 8 个字节为分组序号，这个部分是会逐次累加的。

在加密的过程中，计数器的值会产生如下变化。
```
66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01 // 明文分组1的计数器（初始值）
66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 02 // 明文分组2的计数器
66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 03 // 明文分组3的计数器
...
```
由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也就是说，这种方法就是用分组密码来模拟生成随机的比特序列。
## OFB 模式与 CTR 模式的对比
CTR 模式和 OFB 模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么 OFB 模式和 CTR 模式之间的差异还是很容易理解的。OFB 模式是将加密的输出反馈到输入，而 CTR 模式则是将计数器的值用作输入。

{% asset_img img16.png %}

## CTR 模式的特点
CTR 模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。

此外，CTR 模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的计数器的值可以由`nonce`和分组序号直接计算出来。这一性质是 OFB 模式所不具备的。

能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR 模式的速度非常快。