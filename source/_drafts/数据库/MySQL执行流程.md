


下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。

{% asset_img 1.jpg %}

可以看到， MySQL 的架构共分为两层：`Server`层和存储引擎层：
* `Server`层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在`Server`层实现。
* 存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个`Server`层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

# 连接器
如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：
```
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h$ip -u$user -p
```
连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。如果  MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个`Access denied for user`的错误，然后客户端程序结束执行。

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。

所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
## 如何查看 MySQL 服务被多少个客户端连接了？
如果你想知道当前  MySQL 服务被多少个客户端连接了，你可以执行`show processlist`命令进行查看。
```
mysql> show processlist;
+-----+------+---------------------+-----------+---------+------+----------+------------------+
| Id  | User | Host                | db        | Command | Time | State    | Info             |
+-----+------+---------------------+-----------+---------+------+----------+------------------+
|  17 | root | 172.16.10.110:51976 | skms      | Sleep   | 7291 |          | NULL             |
|  18 | root | 172.16.10.110:51993 | skms      | Sleep   | 7291 |          | NULL             |
|  19 | root | 172.16.10.28:65356  | skms      | Sleep   | 2771 |          | NULL             |
|  20 | root | 172.16.10.28:65357  | skms_user | Sleep   |  230 |          | NULL             |
| 310 | root | 172.16.10.28:51400  | skms_user | Sleep   |  242 |          | NULL             |
| 453 | root | localhost:60498     | skms      | Sleep   |  184 |          | NULL             |
| 454 | root | localhost:60500     | skms      | Sleep   |  225 |          | NULL             |
| 455 | root | localhost           | NULL      | Query   |    0 | starting | show processlist |
+-----+------+---------------------+-----------+---------+------+----------+------------------+
16 rows in set (0.00 sec)
```
比如上图的显示结果，共有 8 个用户连接了 MySQL 服务，其中`id`为 17 的用户的`Command`列的状态为`Sleep`，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 7291 秒（`Time`列）。
## 空闲连接会一直占用着吗？
当然不是了，MySQL 定义了空闲连接的最大空闲时长，由`wait_timeout`参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。
```sql
mysql> show variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```
当然，我们自己也可以手动断开空闲的连接，使用的是`kill connection + id`的命令。
```
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```
一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错`ERROR 2013 (HY000): Lost connection to MySQL server during query`。
## MySQL 的连接数有限制吗？
MySQL 服务支持的最大连接数由`max_connections`参数控制，超过这个值，系统就会拒绝接下来的连接请求，并报错提示`Too many connections`。
```
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```
MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：
```
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```
可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。

