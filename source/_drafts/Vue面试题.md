


## v-html会导致哪些问题
可能会导致xss攻击。
`v-html`会替换掉标签内部的子元素。
`v-html`更新的是元素的`innerHTML`。内容按普通HTML插入，不会作为Vue模板进行编译。
在单文件组件里，`scoped`的样式不会应用在`v-html`内部，因为那部分HTML没有被Vue的模板编译器处理。
## Vue的渲染过程
1. 把模板编译为`render`函数
2. 实例进行挂载, 根据根节点`render`函数的调用，递归的生成虚拟DOM
3. 对比虚拟DOM，渲染到真实DOM
4. 组件内部`data`发生变化，组件和子组件引用`data`作为`props`重新调用`render`函数，生成虚拟DOM, 返回到步骤3

## Vue中的模板编译原理
将`template`转化成`render`函数。
## 组件中的data为什么是函数
因为对象是一个引用数据类型，如果`data`是一个对象的情况下会造成所有组件共用一个`data`。而当`data`是一个函数的情况下，每次函数执行完毕后都会返回一个新的对象，这样的话每个组件都会维护一份独立的对象（`data`）。

## v-for为什么要用key
`key`是为Vue中的`vnode`标记的唯一`id`，通过这个`key`，我们的`diff`操作可以 更准确、更快速

* 准确:如果不加`key`，那么Vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来，会产生一系列的bug
* 快速:`key`的唯一性可以被`Map`数据结构充分利用

## 谈谈你对keep-alive的了解
`keep-alive`是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 。它拥有两个独立的生命周期钩子函数`actived`和`deactived`，使用`keep-alive`包裹的组件在切换时不会被销毁，而是缓存到内存中并执行`deactived`钩子函数，命中缓存渲染后会执行`actived`钩子函数。
## 谈谈你对作用域插槽的理解
单个插槽：
当子组件模板只有一个没有属性的插槽时， 父组件传入的整个内容片段将插入到插槽所在的 DOM 位置， 并替换掉插槽标签本身

命名插槽：
`solt`元素可以用一个特殊的特性`name`来进一步配置如何分发内容。
多个插槽可以有不同的名字。 这样可以将父组件模板中`slot`位置，
和子组件`slot`元素产生关联，便于插槽内容对应传递

作用域插槽：
可以访问组件内部数据的可复用插槽在父级中，具有特殊特性`slot-scope`的`<template>`元素必须存在， 表示它是作用域插槽的模板。`slot-scope`的值将被用作一个临时变量名， 此变量接收从子组件传递过来的`prop`对象

## 为什么v-for和v-if不能连用
当`v-for`和`v-if`处于同一个节点时，`v-for`的优先级比`v-if`更高，这意味着`v-if`将分别重复运行于每个`v-for`循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费。
这种场景建议使用`computed`，先对数据进行过滤。
## Proxy与Object.defineProperty()的对比
`Proxy`的优点：
可以直接监听对象而非属性,并返回一个新对象
可以直接监听数值的变化
可以劫持整个对象，并返回一个新对象

`Proxy`的缺点：
`Proxy`是es6提供的新特性，兼容性不好，所以导致Vue3一致没有正式发布让开发者使用

`Object.defineProperty`的优点：
兼容性好，支持IE9
IE9以下的版本不兼容

`Object.defineProperty`的缺点：
无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应
只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历
