


Go语言是静态类型语言，因此变量是有明确类型的，编译器也会检查变量类型的正确性。

Go语言的基本类型有：
```
bool
string
int、int8、int16、int32、int64
uint、uint8、uint16、uint32、uint64、uintptr
byte // uint8 的别名
rune // int32 的别名 代表一个 Unicode 码
float32、float64
complex64、complex128
```
# 变量的声明
## 标准格式
```
var 变量名 变量类型
```
变量声明以关键字`var`开头，后置变量类型，行尾无须分号。
## 批量格式
```go
var (
  a int
  b string
  c []float32
  d func() bool
  e struct {
    x int
  }
)
```
使用关键字`var`和括号，可以将一组变量定义放在一起。
## 简短格式
```
名字 := 表达式
```
需要注意的是，简短模式有以下限制：
* 定义变量，同时显式初始化。
* 不能提供数据类型。
* 只能用在函数内部。

和`var`形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：
```go
i, j := 0, 1
```
```go
func main() {
  x := 100
  a, s := 1, "abc"
}
```
因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。
# 变量的初始化
当一个变量被声明之后，系统自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：
* 整型和浮点型变量的默认值为 0 和 0.0。
* 字符串变量的默认值为空字符串。
* 布尔型变量默认为`bool`。
* 切片、函数、指针变量的默认为`nil`。

## 变量初始化的标准格式
```
var 变量名 类型 = 表达式
```
```go
var hp int = 100
```
上面代码中，100 和`int`同为`int`类型，`int`可以认为是冗余信息，因此可以进一步简化初始化的写法。
## 编译器推导类型的格式
在标准格式的基础上，将`int`省略后，编译器会尝试根据等号右边的表达式推导`hp`变量的类型。
```go
var hp = 100
```
```go
var attack = 40
var defence = 20
var damageRate float32 = 0.17
var damage = float32(attack-defence) * damageRate
fmt.Println(damage)
```
代码说明如下：
* 第 3 行，表达式的右值中使用了 0.17。由于 Go 语言编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定`damageRate`变量的类型，Go语言编译器会将`damageRate`类型推导为`float64`，我们这里不需要`float64`的精度，所以需要强制指定类型为`float32`。
* 第 4 行，将`attack`和`defence`相减后的数值结果依然为整型，使用`float32()`将结果转换为`float32`类型，再与`float32`类型的`damageRate`相乘后，`damage`类型也是`float32`类型。

## 短变量声明并初始化
```
hp := 100
```
这是 Go 语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。

如果`hp`已经被声明过，但依然使用`:=`时编译器会报错：
```go
// 声明 hp 变量
var hp int
// 再次声明并赋值
hp := 10
```
编译报错如下：
```
no new variables on left side of :=
```
意思是，在`:=`的左边没有新变量出现，意思就是`:=`的左边变量已经被声明了。
```go
conn, err := net.Dial("tcp","127.0.0.1:8080")
```
`net.Dial`提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象（`conn`），一个是错误对象（`err`）。如果是标准格式将会变成：
```go
var conn net.Conn
var err error
conn, err = net.Dial("tcp", "127.0.0.1:8080")
```
因此，短变量声明并初始化的格式在开发中使用比较普遍。

注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错：
```go
conn, err := net.Dial("tcp", "127.0.0.1:8080")
conn2, err := net.Dial("tcp", "127.0.0.1:8080")
```
上面的代码片段，编译器不会报`err`重复定义。
# 多个变量同时赋值
交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：
```go
var a int = 100
var b int = 200
var t int
t = a
a = b
b = t
fmt.Println(a, b)
// 简化写法
var a int = 100
var b int = 200
b, a = a, b
fmt.Println(a, b)
```
多重赋值时，变量的左值和右值按从左到右的顺序赋值。

多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。例如使用Go语言进行排序时就需要使用交换，代码如下：
```go
type IntSlice []int
func (p IntSlice) Len() int           { return len(p) }
func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
```
代码说明如下：
* 第 1 行，将`IntSlice`声明为`[]int`类型。
* 第 3 行，为`IntSlice`类型编写一个`Len`方法，提供切片的长度。
* 第 4 行，根据提供的`i、j`元素索引，获取元素后进行比较，返回比较结果。
* 第 5 行，根据提供的`i、j`元素索引，交换两个元素的值。

# 匿名变量
在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量的特点是一个下画线`_`，`_`本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：
```go
func GetData() (int, int) {
  return 100, 200
}
func main(){
  a, _ := GetData()
  _, b := GetData()
  fmt.Println(a, b)
}
```
代码运行结果：
```
100 200
```
匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。
# 变量的作用域
一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。

Go 语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

根据变量定义位置的不同，可以分为以下三个类型：
* 函数内定义的变量称为局部变量
* 函数外定义的变量称为全局变量
* 函数定义中的变量称为形式参数

## 局部变量
在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。

局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。
```go
package main
import "fmt"
func main() {
  //声明局部变量 a 和 b 并赋值
  var a int = 3
  var b int = 4
  //声明局部变量 c 并计算 a 和 b 的和
  c := a + b
  fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```
运行结果如下所示：
```
a = 3, b = 4, c = 7
```
## 全局变量
在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

全局变量声明必须以`var`关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。
```go
package main
import "fmt"
//声明全局变量
var c int
func main() {
  //声明局部变量
  var a, b int
  //初始化参数
  a = 3
  b = 4
  c = a + b
  fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}

// a = 3, b = 4, c = 7
```
运行结果如下所示：
```

```
Go 语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。
```go
package main
import "fmt"
//声明全局变量
var a float32 = 3.14
func main() {
  //声明局部变量
  var a int = 3
  fmt.Printf("a = %d\n", a)
}

// a = 3
```
## 形式参数
在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。

形式参数会作为函数的局部变量来使用。
```go
package main
import "fmt"
//全局变量 a
var a int = 13
func main() {
  //局部变量 a 和 b
  var a int = 3
  var b int = 4
  fmt.Printf("main() 函数中 a = %d\n", a)
  fmt.Printf("main() 函数中 b = %d\n", b)
  c := sum(a, b)
  fmt.Printf("main() 函数中 c = %d\n", c)
}
func sum(a, b int) int {
  fmt.Printf("sum() 函数中 a = %d\n", a)
  fmt.Printf("sum() 函数中 b = %d\n", b)
  num := a + b
  return num
}
```
运行结果如下所示：
```
main() 函数中 a = 3
main() 函数中 b = 4
sum() 函数中 a = 3
sum() 函数中 b = 4
main() 函数中 c = 7
```
# 整型
Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含`int8、int16、int32、int64`等，每种数值类型都决定了对应的大小范围和是否支持正负符号。

Go 语言同时提供了有符号和无符号的整数类型，其中包括`int8、int16、int32`和`int64`四种大小截然不同的有符号整数类型，分别对应`8、16、32、64 bit`大小的有符号整数，与此对应的是`uint8、uint16、uint32`和`uint64`四种无符号整数类型。

此外还有两种整数类型`int`和`uint`，它们分别对应特定 CPU 平台的字长（机器字大小），其中`int`表示有符号整数，应用最为广泛，`uint`表示无符号整数。实际开发中由于编译器和计算机硬件的不同，`int`和`uint`所能表示的整数大小会在`32bit`或`64bit`之间变化。

大多数情况下，我们只需要`int`一种整型即可，它可以用于循环计数器（`for`循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常`int`类型的处理速度也是最快的。

用来表示 Unicode 字符的`rune`类型和`int32`类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样，`byte`和`uint8`也是等价类型，`byte`类型一般用于强调数值是一个原始的数据而不是一个小的整数。

最后，还有一种无符号的整数类型`uintptr`，它没有指定具体的`bit`大小但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方。

尽管在某些特定的运行环境下`int、uint`和`uintptr`的大小可能相等，但是它们依然是不同的类型，比如`int`和`int32`，虽然`int`类型的大小也可能是`32 bit`，但是在需要把`int`类型当做`int32`类型使用的时候必须显示的对类型进行转换，反之亦然。

Go语言中有符号整数采用 2 的补码形式表示，也就是最高`bit`位用来表示符号位，一个`n-bit`的有符号数的取值范围是从`-2(n-1)`到`2(n-1)-1`。无符号整数的所有`bit`位都用于表示非负数，取值范围是 0 到`2n-1`。例如，`int8`类型整数的取值范围是从 -128 到 127，而`uint8`类型整数的取值范围是从 0 到 255。
## 哪些情况下使用 int 和 uint
程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建`len()`函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或`map`的元素数量等都可以用`int`来表示。

反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和`uint`。
# 浮点类型
Go 语言提供了两种精度的浮点数`float32`和`float64`，它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。

这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在`math`包中找到：
* 常量`math.MaxFloat32`表示`float32`能取到的最大数值，大约是`3.4e38`；
* 常量`math.MaxFloat64`表示`float64`能取到的最大数值，大约是`1.8e308`；

`float32`和`float64`能表示的最小值分别为`1.4e-45`和`4.9e-324`。

一个`float32`类型的浮点数可以提供大约 6 个十进制数的精度，而`float64`则可以提供约 15 个十进制数的精度，通常应该优先使用`float64`类型，因为`float32`类型的累计计算误差很容易扩散，并且`float32`能精确表示的正整数并不是很大。
```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```
浮点数在声明的时候可以只写整数部分或者小数部分：
```go
const e = .71828 // 0.71828
const f = 1.     // 1
```
很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：
```go
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
```
用`Printf`函数打印浮点数时可以使用`%f`来控制保留几位小数
```go
package main
import (
  "fmt"
  "math"
)
func main() {
  fmt.Printf("%f\n", math.Pi)
  fmt.Printf("%.2f\n", math.Pi)
}
```
运行结果如下所示：
```
3.141593
3.14
```
# 复数
在计算机中，复数是由两个浮点数表示的，其中一个表示实部（`real`），一个表示虚部（`imag`）。

Go 语言中复数的类型有两种，分别是`complex128`（64 位实数和虚数）和`complex64`（32 位实数和虚数），其中`complex128`为复数的默认类型。

复数的值由三部分组成`RE + IMi`，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为`float`类型，而最后的 i 是虚数单位。

声明复数的语法格式如下所示：
```
var name complex128 = complex(x, y)
```
其中`name`为复数的变量名，`complex128`为复数的类型，“=”后面的`complex`为 Go 语言的内置函数用于为复数赋值，`x、y`分别表示构成该复数的两个`float64`类型的数值，x 为实部，y 为虚部。

上面的声明语句也可以简写为下面的形式：
```
name := complex(x, y)
```
对于一个复数`z := complex(x, y)`，可以通过 Go 语言的内置函数`real(z)`来获得该复数的实部，也就是 x；通过`imag(z)`获得该复数的虚部，也就是 y。

使用内置的 complex 函数构建复数，并使用 real 和 imag 函数返回复数的实部和虚部：
```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```
复数也可以用`==`和`!=`进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。

Go语言内置的`math/cmplx`包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的`complex128`类型，因为这些内置的包中都使用`complex128`类型作为参数。
# bool类型
一个布尔类型的值只有两种：`true`或`false`。`if`和`for`语句的条件部分都是布尔类型的值，并且`==`和`<`等比较操作也会产生布尔型的值。
```go
var aVar = 10
aVar == 5  // false
aVar == 10 // true
aVar != 5  // true
aVar != 10 // false
```
Go 语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口，那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和`&&（AND）和 ||（OR）`操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：
```
s != "" && s[0] == 'x'
```
其中`s[0]`操作如果应用于空字符串将会导致`panic`异常。

因为`&&`的优先级比`||`高（`&&`对应逻辑乘法，`||`对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：
```go
if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {
  // ...ASCII字母或数字...
}
```
布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用`if`语句显式的进行转换：
```go
i := 0
if b {
  i = 1
}
```
如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：
```go
// 如果b为真，btoi返回1；如果为假，btoi返回0
func btoi(b bool) int {
  if b {
    return 1
  }
  return 0
}
```
数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：
```go
// itob报告是否为非零。
func itob(i int) bool { return i != 0 }
```
Go 语言中不允许将整型强制转换为布尔型，代码如下：
```go
var n bool
fmt.Println(int(n) * 2)
```
编译错误，输出如下：
```
cannot convert n (type bool) to type int
```
布尔型无法参与数值运算，也无法与其他类型进行转换。
# 字符串
一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

UTF-8 是一种被广泛使用的编码格式，是文本文件的标准编码。由于该编码对占用字节长度的不定性，在 Go 语言中字符串也可能根据需要占用 1 至 4 个字节，这与其它编程语言如 Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。
## 定义字符串
可以使用双引号""来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：
\n：换行符
\r：回车符
\t：tab 键
\u 或 \U：Unicode 字符
\\：反斜杠自身

```go
package main
import "fmt"
func main() {
  var str = "hello\nworld"
  fmt.Println(str)
}
```
一般的比较运算符（`==、!=、<、<=、>=、>`）是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数`len()`来获取。

字符串的内容（纯字节）可以通过标准索引法来获取，在方括号[ ]内写入索引，索引从 0 开始计数：
* 字符串`str`的第 1 个字节：`str[0]`
* 第`i`个字节：`str[i - 1]`
* 最后 1 个字节：`str[len(str)-1]`

需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。
## 字符串拼接符“+”
两个字符串`s1`和`s2`可以通过``s := s1 + s2`拼接在一起。将`s2`追加到`s1`尾部并生成一个新的字符串 s。

也可以使用`+=`来对字符串进行拼接：
```go
s := "hel" + "lo,"
s += "world!"
fmt.Println(s) //输出 “hello, world!”
```
Go语言中字符串的内部实现使用 UTF-8 编码，通过`rune`类型，可以方便地对每个 UTF-8 字符进行访问。当然，Go 语言也支持按照传统的 ASCII 码方式逐字符进行访问。
## 定义多行字符串
在 Go 语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用`反引号，代码如下：
```go
const str = `第一行
第二行
第三行
\r\n
`
fmt.Println(str)
```
代码运行结果：
```
第一行
第二行
第三行
\r\n
```
两个反引号间的字符串将被原样赋值到`str`变量中。

在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

在`间的所有代码均不会被编译器识别，而只是作为字符串的一部分。
# 字符类型
字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。

Go语言的字符有以下两种：
* 一种是`uint8`类型，或者叫`byte`型，代表了 ASCII 码的一个字符。
* 另一种是`rune`类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型等价于`int32`类型。

`byte`类型是`uint8`的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题，例如`var ch byte = 'A'`，字符使用单引号括起来。

在 ASCII 码表中，A 的值是 65，使用 16 进制表示则为 41，所以下面的写法是等效的：
```
var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）
```
另外一种可能的写法是\后面紧跟着长度为 3 的八进制数，例如 \377。

Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者`runes`，并在内存中使用`int`来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀`\u`或者`\U`。因为 Unicode 至少占用 2 个字节，所以我们使用`int16`或者`int`类型来表示。如果需要使用到 4 字节，则使用`\u`前缀，如果需要使用到 8 个字节，则使用`\U`前缀。
```
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point
```
输出：
```
65 - 946 - 1053236
A - β - r
41 - 3B2 - 101234
U+0041 - U+03B2 - U+101234
```
格式化说明符`%c`用于表示字符，当和字符配合使用时，%v或%d会输出用于表示该字符的整数，`%U`输出格式为`U+hhhh`的字符串。

Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 ch 代表字符）：
* 判断是否为字母：`unicode.IsLetter(ch)`
* 判断是否为数字：`unicode.IsDigit(ch)`
* 判断是否为空白符号：`unicode.IsSpace(ch)`

## UTF-8 和 Unicode 区别
Unicode 与 ASCII 类似，都是一种字符集。

字符集为每个字符分配一个唯一的 ID，我们使用到的所有字符在 Unicode 字符集中都有一个唯一的 ID，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。汉字“你”在 Unicode 中的编码为 20320，在不同国家的字符集中，字符所对应的 ID 也会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。

UTF-8 是编码规则，将 Unicode 中字符的 ID 以某种方式进行编码，UTF-8 的是一种变长编码规则，从 1 到 4 个字节不等。编码规则如下：
* 0xxxxxx 表示文字符号 0～127，兼容 ASCII 字符集。
* 从 128 到 0x10ffff 表示其他字符。

根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 3 个字节。

广义的 Unicode 指的是一个标准，它定义了字符集及编码规则，即 Unicode 字符集和 UTF-8、UTF-16 编码等。
# 数据类型转换
在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：
```
valueOfTypeB = typeB(valueOfTypeA)

类型 B 的值 = 类型 B(类型 A 的值)
```
```go
a := 5.0
b := int(a)
```
类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。

只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）：
```go
package main
import (
  "fmt"
  "math"
)
func main() {
  // 输出各数值范围
  fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)
  fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)
  fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)
  fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)
  // 初始化一个32位整型值
  var a int32 = 1047483647
  // 输出变量的十六进制形式和十进制值
  fmt.Printf("int32: 0x%x %d\n", a, a)
  // 将a变量数值转换为十六进制, 发生数值截断
  b := int16(a)
  // 输出变量的十六进制形式和十进制值
  fmt.Printf("int16: 0x%x %d\n", b, b)
  // 将常量保存为float32类型
  var c float32 = math.Pi
  // 转换为int类型, 浮点发生精度丢失
  fmt.Println(int(c))
}
```
代码说明如下：
* 第 11～14 行，输出几个常见整型类型的数值范围。
* 第 17 行，声明 int32 类型的变量 a 并初始化。
* 第 19 行，使用 fmt.Printf 的%x动词将数值以十六进制格式输出，这一行输出 a 在转换前的 32 位的值。
* 第 22 行，将 a 的值转换为 int16 类型，也就是从 32 位有符号整型转换为 16 位有符号整型，由于 int16 类型的取值范围比 int32 类型的取值范围小，因此数值会进行截断（精度丢失）。
* 第 24 行，输出转换后的 a 变量值，也就是 b 的值，同样以十六进制和十进制两种方式进行打印。
* 第 27 行，math.Pi 是 math 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 math.Pi 被赋值到变量 c 中，因此类型为 float32。
* 第 29 行，将 float32 转换为 int 类型并输出。

代码输出如下：
```
int8 range: -128 127
int16 range: -32768 32767
int32 range: -2147483648 2147483647
int64 range: -9223372036854775808 9223372036854775807
int32: 0x3e6f54ff 1047483647
int16: 0x54ff 21759
3
```
根据输出结果，16 位有符号整型的范围是 -32768～32767，而变量 a 的值 1047483647 不在这个范围内。1047483647 对应的十六进制为 0x3e6f54ff，转为 int16 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 0x54ff，对应的十进制值为 21759。

浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。

