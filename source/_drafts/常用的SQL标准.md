

我们知道 SQL 的英文全称叫做`Structured Query Language`，它有一个很强大的功能，就是能在各个数据表之间进行连接查询（`Query`）。这是因为 SQL 是建立在关系型数据库基础上的一种语言。关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（`Structured`）。你可以把关系模型理解成一个二维表格模型，这个二维表格是由行（`row`）和列（`column`）组成的。每一个行（`row`）就是一条数据，每一列（`column`）就是数据在某一维度的属性。

正是因为在数据库中，表的组成是基于关系模型的，所以一个表就是一个关系。一个数据库中可以包括多个表，也就是存在多种数据之间的关系。而我们之所以能使用 SQL 语言对各个数据表进行复杂查询，核心就在于连接，它可以用一条`SELECT`语句在多张表之间进行查询。你也可以理解为，关系型数据库的核心之一就是连接。
# 常用的 SQL 标准有哪些
在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。

SQL 有两个主要的标准，分别是 SQL92 和 SQL99。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。

这么多标准，到底该学习哪个呢？实际上最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上你不用担心要学习这么多内容，基本上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。

# 在 SQL92 中是如何使用连接的
相比于 SQL99，SQL92 规则更简单，更适合入门。在这篇文章中，我会先讲 SQL92 是如何对连接表进行操作的，下一篇文章再讲 SQL99，到时候你可以对比下这两者之间有什么区别。

在进行连接之前，我们需要用数据表做举例。这里我创建了 NBA 球员和球队两张表，SQL 文件你可以从GitHub上下载。

其中 player 表为球员表，一共有 37 个球员，如下所示：
| player_id | team_id | player_name | height |
| :--: | :--: | :--: | :--: |
| 10001 | 1001 | 韦恩·艾灵顿 | 1.93 |
| 10002 | 1001 | 雷吉·杰克逊 | 1.91 |
| 10003 | 1001 | 安德烈·德拉蒙德 | 2.11 |
| 10004 | 1001 | 索恩·马克 | 2.16 |
| ... | ... | ... | ... |
| 10037 | 1001 | 伊凯·阿尼博古 | 2.08 |
team 表为球队表，一共有 3 支球队，如下所示：
| team_id | team_name |
| :--: | :--: |
| 1001 | 底特律活塞 |
| 1002 | 印第安纳步行者 |
| 1003 | 亚特兰大老鹰 |
有了这两个数据表之后，我们再来看下 SQL92 中的 5 种连接方式，它们分别是笛卡尔积、等值连接、非等值连接、外连接（左连接、右连接）和自连接。

笛卡尔积
笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。

我们假定 player 表的数据是集合 X，先进行 SQL 查询：

SELECT * FROM player
再假定 team 表的数据为集合 Y，同样需要进行 SQL 查询：

SELECT * FROM team
你会看到运行结果会显示出上面的两张表格。

接着我们再来看下两张表的笛卡尔积的结果，这是笛卡尔积的调用方式：

SQL: SELECT * FROM player, team
运行结果（一共 37*3=111 条记录）：
| player_id | team_id | player_name | height | team_id(1) | team_name |
| :--: | :--: | :--: | :--: | :--: | :--: |
| 10001 | 1001 | 韦恩·艾灵顿 | 1.93 | 1001 | 底特律活塞 |
| 10002 | 1001 | 韦恩·艾灵顿 | 1.91 | 1002 | 印第安纳步行者 |
| 10003 | 1001 | 韦恩·艾灵顿 | 2.11 | 1003 | 亚特兰大老鹰 |
| ... | ... | ... | ... | ... |
| 10037 | 1002 | 伊凯·阿尼博古 | 2.08 | 亚特兰大老鹰 |
笛卡尔积也称为交叉连接，英文是 CROSS JOIN，它的作用就是可以把任意表进行连接，即使这两张表不相关。但我们通常进行连接还是需要筛选的，因此你需要在连接后面加上 WHERE 子句，也就是作为过滤条件对连接数据进行筛选。比如后面要讲到的等值连接。

等值连接
两张表的等值连接就是用两张表中都存在的列进行连接。我们也可以对多张表进行等值连接。

针对 player 表和 team 表都存在 team_id 这一列，我们可以用等值连接进行查询。

SQL: SELECT player_id, player.team_id, player_name, height, team_name FROM player, team WHERE player.team_id = team.team_id
运行结果（一共 37 条记录）：
| player_id | team_id | player_name | height | team_name |
| :--: | :--: | :--: | :--: | :--: |
| 10001 | 1001 | 韦恩·艾灵顿 | 1.93 | 底特律活塞 |
| 10002 | 1001 | 雷吉·杰克逊 | 1.91 | 底特律活塞 |
| 10003 | 1001 | 安德烈·德拉蒙德 | 2.11 | 底特律活塞 |
| ... | ... | ... | ... | ... |
| 10037 | 1001 | 伊凯·阿尼博古 | 2.08 | 印第安纳步行者 |
我们在进行等值连接的时候，可以使用表的别名，这样会让 SQL 语句更简洁：

SELECT player_id, a.team_id, player_name, height, team_name FROM player AS a, team AS b WHERE a.team_id = b.team_id
需要注意的是，如果我们使用了表的别名，在查询字段中就只能使用别名进行代替，不能使用原有的表名，比如下面的 SQL 查询就会报错：

SELECT player_id, player.team_id, player_name, height, team_name FROM player AS a, team AS b WHERE a.team_id = b.team_id
非等值连接
当我们进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符连接就是非等值查询。

这里我创建一个身高级别表 height_grades，如下所示：

| height_level | height_lowest | height_highest |
| :--: | :--: | :--: |
| A | 2.00 | 2.50 |
| B | 1.90 | 1.99 |
| C | 1.80 | 1.89 |
| D | 1.60 | 1.79 |
我们知道 player 表中有身高 height 字段，如果想要知道每个球员的身高的级别，可以采用非等值连接查询。

SQL：SELECT p.player_name, p.height, h.height_level
FROM player AS p, height_grades AS h
WHERE p.height BETWEEN h.height_lowest AND h.height_highest
运行结果（37 条记录）：