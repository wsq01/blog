


# 冒泡排序算法
使用冒泡排序算法对`n`个数据进行排序，实现思路是：从待排序序列中找出一个最大值或最小值，这样的操作执行`n-1`次，最终就可以得到一个有序序列。

对`{14, 33, 27, 35, 10}`序列进行升序排序（由小到大排序），冒泡排序算法的实现过程是：
1. 从`{14, 33, 27, 35, 10}`中找到最大值 35；
2. 从`{14,33,27,10}`中找到最大值 33；
3. 从`{14, 27, 10}`中找到最大值 27；
4. 从`{14, 10}`中找到最大值 14；

由此，我们就得到了一个有序序列`{10, 14, 27, 33, 35}`。

那么，如何从待排序序列中找到最大（或最小）的值呢？以找最大值为例，遍历待排序序列，过程中不断地比较相邻两个元素的值，如果后者比前者的值小就交换它们的位置。遍历完成后，最后一个元素就是当前待排序序列中最大的。

例如，从`{14, 33, 27, 35, 10}`中找到最大值 35 的过程如下：
1. 比较 14 和 33 的大小，显然后者更大，不需要交换它们的位置，序列不发生改变。
{% asset_img 1-1.gif %}
2. 比较 33 和 27 的大小，前者大于后者，交换它们的位置，新的序列如下图所示。
{% asset_img 1-2.gif %}
3. 比较 33 和 35 的大小，后者更大，不需要交换它们的位置，序列不发生改变。
{% asset_img 1-3.gif %}
4. 比较 35 和 10 的大小，前者大于后者，交换它们的位置，新的序列如下图所示。
{% asset_img 1-4.gif %}

可以看到，序列中值最大的元素 35 被移动到了序列的末尾。整个查找最大值的过程中，最大的元素就像水里的气泡一样，一点一点地“冒”了出来，这也是将该算法命名为冒泡排序算法的原因。

采用同样的方法，我们可以很轻松地从`{14, 27, 33, 10}`中找到最大值 33。找到 33 后的新序列为：

{% asset_img 1-5.gif %}

从`{14, 27, 10}`中找到最大值 27 后，新的序列如下图所示：

{% asset_img 1-6.gif %}

从`{14, 10}`中找到最大值 14 后，新的序列如下图所示：

{% asset_img 1-7.gif %}

所有比 10 大的数都被一一找到，所以 10 必然是最小的数，这也是为什么“对`n`个数据进行排序，找最大值的过程只重复`n-1`次”的原因。
## 冒泡排序算法的具体实现
如下是冒泡排序算法实现升序排序的伪代码：
```
Bubble_sort(list):                         // list 表示待排序序列
    for i <- 0 to length(list)-1:          // 对于元素个数为 n 的 list 序列，需遍历 n-1 次，这里用 [0,length(list)-1) 表示。
        for j <- 1 to length(list) - i:    // 从第 1 个元素开始遍历，遍历区间为 [1,length(list)-i)。
            if list[j] > list[j+1]:        // 若进行降序排序，则改成 < 小于号
                 swap(list[j] , list[j+1]) // 交换 2 个相邻元素的位置
    return list                            // 返回排好序的序列
```
根据伪代码，冒泡排序算法的时间复杂度为`O(n2)`。

如下是用冒泡排序算法对`{14, 33, 27, 35, 10}`完成升序排序的 Java 程序：
```java
public class Demo {
    public static void Bubble_sort(int[] list) {
        int length = list.length;
        // length 个元素，遍历 length-1 次
        for (int i = 0; i < length-1; i++) {
            // 从第 1 个元素开始遍历，遍历至 length-1-i
            for (int j = 0; j < length - 1 - i; j++) {
                // 比较 list[j] 和 list[j++] 的大小
                if (list[j] > list[j + 1]) {
                    // 交换 2 个元素的位置
                    int temp = list[j];
                    list[j] = list[j + 1];
                    list[j + 1] = temp;
                }
            }
        }
    }
    public static void main(String[] args) {
        int[] list = { 14, 33, 27, 35, 10 };
        Bubble_sort(list);
        // 输出已排好序的序列
        for (int i = 0; i < list.length; i++) {
            System.out.print(list[i] + " ");
        }
    }
}
```
以上程序的输出结果均为：
```
10 14 27 33 35
```
# 插入排序算法
插入排序算法可以对指定序列完成升序（从小到大）或者降序（从大到小）排序，对应的时间复杂度为 O(n<pub>2</pub>)。

插入排序算法的实现思路是：初始状态下，将待排序序列中的第一个元素看作是有序的子序列。从第二个元素开始，在不破坏子序列有序的前提下，将后续的每个元素插入到子序列中的适当位置。

用插入排序算法对`{14, 33, 27, 10, 35, 19, 42, 44}`实现升序排序的过程如下：
1. 将第一个元素 14 看作是一个有序的子序列`{14}`，将剩余元素逐个插入到此序列的适当位置：
{% asset_img 2-1.gif %}
2. 将 33 插入到`{14}`中，由于`33 > 14`，所以 33 应该插入到 14 的后面，新的有序序列变为`{14, 33}`；
{% asset_img 2-2.gif %}
3. 将 27 插入到`{14, 33}`中，由于`27 < 33`同时`27 > 14`，所以 27 应该插入到 14 和 33 的中间，新的有序序列变为`{14, 27, 33}`；
{% asset_img 2-3.gif %}
4. 将 10 插入到`{14, 27, 33}`中，经过依次和 33、27、14 比较，最终断定 10 应该插入到 14 之前，新的有序序列变为`{10, 14, 27, 33}`；
{% asset_img 2-4.gif %}
5. 将 35 插入到`{10, 14, 27, 33}`中，由于`35 > 33`，所以 35 应该插入到 33 之后，新的有序序列变为`{10, 14, 27, 33, 35}`；
{% asset_img 2-5.gif %}
6. 将 19 插入到`{10, 14, 27, 33, 35} `中，经过依次和 35、33、27、14 比较，最终断定 19 应该插入到 14 和 27 之间，新的有序序列变为 {10, 14, 19, 27, 33, 35}；
{% asset_img 2-6.gif %}
7. 将 42 插入到`{10, 14, 19, 27, 33, 35}`中，由于`42 > 35`，所以 42 应插入到 35 之后，新的有序序列变为`{10, 14, 19, 27, 33, 35, 42}`；
{% asset_img 2-7.gif %}
8. 将 44 插入到`{10, 14, 19, 27, 33, 35, 42}`中，由于`44 > 42`，所以 44 应插入到 42 之后，新的有序序列变为`{10, 14, 19, 27, 33, 35, 42, 44}`。
{% asset_img 2-8.gif %}


经过将各个待排序的元素插入到有序序列的适当位置，最终得到的就是一个包含所有元素的有序序列。
## 插入排序算法的具体实现
实现插入排序算法的伪代码如下：
```
// list 为待排序序列
insertion_sort(list):
    // 从第 2 个元素开始遍历序列
    for i <- 2 to length(list):
        //记录要插入的目标元素
        insert_elem = list[i]
        //记录目标元素所在的位置
        position = i
        //从 position 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置
        while position > 0 and list[position-1] > insert_elem:      // 此为升序排序，实现降序排序改为 list[position-1] < insert_elem
            //移动前一个元素的位置，将其向后移动一个位置
            list[position] = list[position-1]
            position = position - 1
        if(position != i):
            list[position] = insert_elem
    return list
```
如下是用插入排序算法对 {14, 33, 27, 10, 35, 19, 42, 44} 实现升序排序的 Java 程序：
```java
public class Demo {
    public static void insertion_sort(int[] list) {
        int length = list.length;
        // 从第 2 个元素（下标为 1）开始遍历
        for (int i = 1; i < length; i++) {
            // 记录要插入的目标元素
            int insert_elem = list[i];
            // 记录目标元素所在的位置，从此位置向前开始遍历
            int position = i;
            // 从 position 向前遍历，找到目标元素的插入位置
            while (position > 0 && list[position - 1] > insert_elem) {
                // position 处的元素向后移动一个位置
                list[position] = list[position - 1];
                position--;
            }
            // 将目标元素插入到指定的位置
            if (position != i) {
                list[position] = insert_elem;
            }
        }
    }
    public static void main(String[] args) {
        int[] list = { 10, 14, 19, 27, 33, 35, 42, 44 };
        insertion_sort(list);
        // 输出已排好序的序列
        for (int i = 0; i < list.length; i++) {
            System.out.print(list[i] + " ");
        }
    }
}
```
输出结果均为：
```
10 14 19 27 33 35 42 44 
```