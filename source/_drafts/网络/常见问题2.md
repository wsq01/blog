

# HTTPS 一定安全可靠吗？
这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

{% asset_img 1.png %}

具体过程如下：
* 客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；
* 在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。
* 在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。
* 后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。
从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。

那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

{% asset_img 2.png %}

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。
## 客户端是如何验证证书的？
接下来，详细说一下实际中数字证书签发和验证流程。

如下图图所示，为数字证书签发和验证流程：

{% asset_img 3.png %}

当服务端向 CA 机构申请证书的时候，CA 签发证书的过程，如上图左边部分：
* 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行`Hash`计算，得到一个`Hash`值；
* 然后 CA 会使用自己的私钥将该`Hash`值加密，生成`Certificate Signature`，也就是 CA 对证书做了签名；
* 最后将`Certificate Signature`添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：
* 首先客户端会使用同样的`Hash`算法获取该证书的`Hash`值 H1；
* 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密`Certificate Signature`内容，得到一个`Hash`值 H2 ；
* 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

{% asset_img 4.png %}

对于这种三级层级关系的证书的验证过程如下：
* 客户端收到`baidu.com`的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证`baidu.com`证书是否可信。于是，客户端根据`baidu.com`证书中的签发者，找到该证书的颁发机构是`GlobalSign Organization Validation CA - SHA256 - G2`，然后向 CA 请求该中间证书。
* 请求到证书后发现`GlobalSign Organization Validation CA - SHA256 - G2`证书是由`GlobalSign Root CA`签发的，由于`GlobalSign Root CA`没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证`GlobalSign Organization Validation CA - SHA256 - G2`证书，如果发现验证通过，就认为该中间证书是可信的。
* `GlobalSign Organization Validation CA - SHA256 - G2`证书被信任后，可以使用`GlobalSign Organization Validation CA - SHA256 - G2`证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任`baidu.com`证书。

在这四个步骤中，最开始客户端只信任根证书`GlobalSign Root CA`证书的，然后`GlobalSign Root CA`证书信任`GlobalSign Organization Validation CA - SHA256 - G2`证书，而`GlobalSign Organization Validation CA - SHA256 - G2`证书又信任`baidu.com`证书，于是客户端也信任`baidu.com`证书。总括来说，由于用户信任`GlobalSign`，所以由`GlobalSign`所担保的`baidu.com`可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的`GlobalSign`都可被信任。

{% asset_img 5.png %}

操作系统里一般都会内置一些根证书：

{% asset_img 6.png %}

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

{% asset_img 7.png %}

如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的。

这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。

所以，HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。
## 为什么抓包工具能截取 HTTPS 数据？
抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:

中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：
* 去网站服务端拿到私钥；
* 去CA处拿域名签发私钥；
* 自己签发证书，且被浏览器信任；
  
不用解释，抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。

Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。

客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。
## 如何避免被中间人抓取数据？
我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们还可以通过 HTTPS 双向认证来避免这种问题。

一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。

{% asset_img 8.png %}

服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

# HTTPS 会加密 URL 吗？
答案是，会加密的。

因为 URL 的信息都是保存在 HTTP Header 中的，而 HTTPS 是会对 HTTP Header + HTTP Body 整个加密的，所以 URL 自然是会被加密的。

下图是 HTTP/1.1 的请求头部，可以看到是包含 URL 信息的。

{% asset_img 11.png %}

对应的实际的 HTTP/1.1 的请求头部：

{% asset_img 12.png %}

HTTP/1.1 请求的第一行包含请求方法和路径。HTTP/2 用一系列伪头部替换了请求行，这五个伪头部很容易识别，因为它们在名称的开头用了一个冒号来表示。

比如请求方法和路径伪头字段如下：
* ":method" 伪头字段包含了 HTTP 方法；
* ":path" 伪头字段包含目标 URL 的路径和查询部分；

{% asset_img 13.png %}

上图是我浏览器 F12 开发者工具查看的信息，浏览器显示信息是已经解密后的信息，所以不要误以为 URL 没有加密。

如果你用抓包工具，抓包 HTTPS 的数据的话，你是什么都看不到的，如下图，只会显示`Application Data`，表示这是一个已经加密的 HTTP 应用数据。

{% asset_img 14.png %}

## HTTPS 可以看到域名吗？
从上面我们知道，HTTPS 是已经把 HTTP Header + HTTP Body 整个加密的，所以我们是无法从加密的 HTTP 数据中获取请求的域名的。

但是我们可以在 TLS 握手过程中看到域名信息。

比如下图，TLS 第一次握手的 “Client Hello” 消息中，有个`server name`字段，它就是请求的域名地址。

{% asset_img 15.png %}

所以，用了 HTTPS 也不能以为偷偷在公司上某 hub 不会被发现。
## HTTPS 的应用数据是如何保证完整性的？
然后很多读者以为 HTTP 数据就用对称加密密钥（TLS 握手过程中协商出来的对称加密密钥）加密后就直接发送了，然后就疑惑 HTTP 数据有没有通过摘要算法来保证完整性？

事实上，TLS 在实现上分为握手协议和记录协议两层：
* TLS 握手协议就是我们说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
* TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

{% asset_img 16.png %}

具体过程如下：
* 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
* 接下来，经过压缩的片段会被加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
* 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
* 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的加密报文数据。

记录协议完成后，最终的加密报文数据将传递到传输控制协议 (TCP) 层进行传输。

# TCP 和 UDP 可以同时绑定相同的端口吗？
答案：可以的。

TCP 和 UDP 服务端网络相似的一个地方，就是会调用`bind`绑定端口。

TCP 网络编程如下，服务端执行`listen()`系统调用就是监听端口的动作。

{% asset_img 21.png TCP网络编程 %}

UDP 网络编程如下，服务端是没有监听这个动作的，只有执行`bind()`系统调用来绑定端口的动作。

{% asset_img 22.png UDP网络编程 %}

在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。

所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。

传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

{% asset_img 23.png %}

因此， TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。
# 多个 TCP 服务进程可以绑定同一个端口吗？
还是以前面的 TCP 服务端程序作为例子，启动两个同时绑定同一个端口的 TCP 服务进程。

运行第一个 TCP 服务进程之后，`netstat`命令可以查看，8888 端口已经被一个 TCP 服务进程绑定并监听了。

接着，运行第二个 TCP 服务进程的时候，就报错了`Address already in use`。

上面的情况是两个 TCP 服务进程同时绑定地址和端口是：`0.0.0.0`地址和 8888 端口，所以才出现的错误。

如果两个 TCP 服务进程绑定的 IP 地址不同，而端口相同的话，也是可以绑定成功的，如下图：

{% asset_img 27.png %}

所以，默认情况下，针对「多个 TCP 服务进程可以绑定同一个端口吗？」这个问题的答案是：如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行`bind()`时候就会出错，错误是`Address already in use`。

注意，如果 TCP 服务进程 A 绑定的地址是`0.0.0.0`和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。

这是因为`0.0.0.0`地址比较特殊，代表任意地址，意味着绑定了`0.0.0.0`地址，相当于把主机上的所有 IP 地址都绑定了。
## 重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？
TCP 服务进程需要绑定一个 IP 地址和一个端口，然后就监听在这个地址和端口上，等待客户端连接的到来。

然后在实践中，我们可能会经常碰到一个问题，当 TCP 服务进程重启之后，总是碰到`Address in use`的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。

当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在`TIME_WAIT`这个状态里停留一段时间，这个时间大约为 2MSL。

{% asset_img 24.png %}

当 TCP 服务进程重启时，服务端会出现`TIME_WAIT`状态的连接，`TIME_WAIT`状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行`bind()`函数的时候，就会返回了`Address already in use`的错误。

而等`TIME_WAIT`状态的连接结束后，重启 TCP 服务进程就能成功。
## 重启 TCP 服务进程时，如何避免“Address in use”的报错信息？
我们可以在调用`bind`前，对`socket`设置`SO_REUSEADDR`属性，可以解决这个问题。
```
int on = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
```
因为`SO_REUSEADDR`作用是：如果当前启动进程绑定的 IP+PORT 与处于`TIME_WAIT`状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了`SO_REUSEADDR`选项，那么该进程就可以绑定成功。

举个例子，服务端有个监听`0.0.0.0`地址和 8888 端口的 TCP 服务进程。‍

有个客户端（IP地址：`192.168.1.100`）已经和服务端（IP 地址：`172.19.11.200`）建立了 TCP 连接，那么在 TCP 服务进程重启时，服务端会与客户端经历四次挥手，服务端的 TCP 连接会短暂处于`TIME_WAIT`状态：
```
客户端地址:端口           服务端地址:端口        TCP 连接状态
192.168.1.100:37272     172.19.11.200:8888    TIME_WAIT
```
如果 TCP 服务进程没有对`socket`设置`SO_REUSEADDR`属性，那么在重启时，由于存在一个和绑定 IP+PORT 一样的`TIME_WAIT`状态的连接，那么在执行`bind()`函数的时候，就会返回了`Address already in use`的错误。

如果 TCP 服务进程对`socket`设置`SO_REUSEADDR`属性了，那么在重启时，即使存在一个和绑定 IP+PORT 一样的`TIME_WAIT`状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

因此，在所有 TCP 服务器程序中，调用`bind`之前最好对`socket`设置`SO_REUSEADDR`属性，这不会产生危害，相反，它会帮助我们在很快时间内重启服务端程序。‍

前面我提到过这个问题：如果 TCP 服务进程 A 绑定的地址是`0.0.0.0`和端口 8888，而如果 TCP 服务进程 B 绑定的地址是`192.168.1.100`地址（或者其他地址）和端口 8888，那么执行`bind()`时候也会出错。

这个问题也可以由`SO_REUSEADDR`解决，因为它的另外一个作用是：绑定的 IP地址 + 端口时，只要 IP 地址不是正好相同，那么允许绑定。

比如，`0.0.0.0:8888`和`192.168.1.100:8888`，虽然逻辑意义上前者包含了后者，但是`0.0.0.0`泛指所有本地 IP，而`192.168.1.100`特指某一 IP，两者并不是完全相同，所以在对`socket`设置`SO_REUSEADDR`属性后，那么执行`bind()`时候就会绑定成功。
## 客户端的端口可以重复使用吗？
客户端在执行`connect`函数的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。

{% asset_img 25.png %}

所以，客户端的端口选择的发生在`connect`函数，内核在选择端口的时候，会从`net.ipv4.ip_local_port_range`这个内核参数指定的范围来选取一个端口作为客户端端口。

该参数的默认值是`32768 61000`，意味着端口总可用的数量是`61000 - 32768 = 28232`个。

当客户端与服务端完成 TCP 连接建立后，我们可以通过`netstat`命令查看 TCP 连接。
```
$ netstat -napt
```
协议  源ip地址:端口            目的ip地址：端口         状态
tcp  192.168.110.182.64992   117.147.199.51.443     ESTABLISHED

那问题来了，上面客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？

这个问题，很多同学都会说不可以继续使用该端口了，如果按这个理解的话， 默认情况下客户端可以选择的端口是 28232 个，那么意味着客户端只能最多建立  28232 个 TCP 连接，如果真是这样的话，那么这个客户端并发连接也太少了吧，所以这是错误理解。

正确的理解是，TCP 连接是由四元组（源 IP 地址，源端口，目的 IP 地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

比如下面这张图，有 2 个 TCP 连接，左边是客户端，右边是服务端，客户端使用了相同的端口 50004 与两个服务端建立了 TCP 连接。

{% asset_img 28.jpg %}

仔细看，上面这两条 TCP 连接的四元组信息中的「目的 IP 地址」是不同的，一个是`180.101.49.12`，另外一个是`180.101.49.11`。
## 多个客户端可以`bind`同一个端口吗？
`bind`函数虽然常用于服务端网络编程中，但是它也是用于客户端的。

前面我们知道，客户端是在调用`connect`函数的时候，由内核随机选取一个端口作为连接的端口。

而如果我们想自己指定连接的端口，就可以用`bind`函数来实现：客户端先通过`bind`函数绑定一个端口，然后调用`connect`函数就会跳过端口选择的过程了，转而使用`bind`时确定的端口。

针对这个问题：多个客户端可以`bind`同一个端口吗？

要看多个客户端绑定的 IP + PORT 是否都相同，如果都是相同的，那么在执行`bind()`时候就会出错，错误是`Address already in use`。

如果一个绑定在`192.168.1.100:6666`，一个绑定在`192.168.1.200:6666`，因为 IP 不相同，所以执行`bind()`的时候，能正常绑定。

所以， 如果多个客户端同时绑定的 IP 地址和端口都是相同的，那么执行`bind()`时候就会出错，错误是`Address already in use`。

一般而言，客户端不建议使用`bind`函数，应该交由`connect`函数来选择端口会比较好，因为客户端的端口通常都没什么意义。

客户端 TCP 连接`TIME_WAIT`状态过多，会导致端口资源耗尽而无法建立新的连接吗？

针对这个问题要看，客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。

如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端`TIME_WAIT`状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。

但是，因为只要客户端连接的服务器不同，端口资源可以重复使用的。

所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。

如何解决客户端 TCP 连接`TIME_WAIT`过多，导致无法与同一个服务器建立连接的问题？

前面我们提到，如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端`TIME_WAIT`状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。

针对这个问题，也是有解决办法的，那就是打开`net.ipv4.tcp_tw_reuse`这个内核参数。

因为开启了这个内核参数后，客户端调用`connect`函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于`TIME_WAIT`状态，如果该连接处于`TIME_WAIT`状态并且`TIME_WAIT`状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

举个例子，假设客户端已经与服务器建立了一个 TCP 连接，并且这个状态处于`TIME_WAIT`状态：
```
客户端地址:端口           服务端地址:端口         TCP 连接状态
192.168.1.100:2222      172.19.11.21:8888     TIME_WAIT
```
然后客户端又与该服务器（`172.19.11.21:8888`）发起了连接，在调用`connect`函数时，内核刚好选择了 2222 端口，接着发现已经被相同四元组的连接占用了：
* 如果没有开启`net.ipv4.tcp_tw_reuse`内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口， 如果端口资源耗尽还是没找到，那么`connect`函数就会返回错误。
* 如果开启了`net.ipv4.tcp_tw_reuse`内核参数，就会判断该四元组的连接状态是否处于`TIME_WAIT`状态，如果连接处于`TIME_WAIT`状态并且该状态持续的时间超过了 1 秒，那么就会重用该连接，于是就可以使用 2222 端口了，这时`connect`就会返回成功。

再次提醒一次，开启了`net.ipv4.tcp_tw_reuse`内核参数，是客户端（连接发起方） 在调用`connect()`函数时才起作用，所以在服务端开启这个参数是没有效果的。
## 客户端端口选择的流程总结
至此，我们已经把客户端在执行`connect`函数时，内核选择端口的情况大致说了一遍，为了让大家更明白客户端端口的选择过程，我画了一流程图。

{% asset_img 26.jpg %}

## 总结
TCP 和 UDP 可以同时绑定相同的端口吗？可以的。

TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

因此， TCP/UDP 各自的端口号也相互独立，互不影响。

多个 TCP 服务进程可以同时绑定同一个端口吗？

如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行`bind()`时候就会出错，错误是`Address already in use`。

如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行`bind()`不会出错。

如何解决服务端重启时，报错`Address already in use`的问题？

当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在`TIME_WAIT`这个状态里停留一段时间，这个时间大约为 2MSL。

当 TCP 服务进程重启时，服务端会出现`TIME_WAIT`状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行`bind()`函数的时候，就会返回了`Address already in use`的错误。

要解决这个问题，我们可以对`socket`设置`SO_REUSEADDR`属性。

这样即使存在一个和绑定 IP+PORT 一样的`TIME_WAIT`状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

客户端的端口可以重复使用吗？

在客户端执行`connect`函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。

TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。

所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

客户端 TCP 连接`TIME_WAIT`状态过多，会导致端口资源耗尽而无法建立新的连接吗？

要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。

如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端`TIME_WAIT`状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。

如何解决客户端 TCP 连接`TIME_WAIT`过多，导致无法与同一个服务器建立连接的问题？

打开`net.ipv4.tcp_tw_reuse`这个内核参数。

因为开启了这个内核参数后，客户端调用`connect`函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于`TIME_WAIT`状态。

如果该连接处于`TIME_WAIT`状态并且`TIME_WAIT`状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

