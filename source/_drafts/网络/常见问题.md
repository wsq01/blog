

# 客户端连接一个不存在的 IP 地址，会发生什么？
这里的「连接」指的是 TCP 连接。

这个问题要分两种情况来思考，不同的情况得到的结论是不同的。

## 第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。
第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。

因为目标地址不存在 IP 地址，客户端的内核在发`arp`请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的`arp`请求。

由于客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去。

第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。

第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。

由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放。

为什么这种情况客户端的 SYN 报文可以发出来？

因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端通过路由表的判断，判断到下一步是要将网络报文发送给路由器。

这时候数据链路层的`arp`请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。

然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是`SYN`报文就可以发送出去了。

由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。
# 客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？
客户端连接的目标 IP 地址是存在的，那么`SYN`报文就能正确的抵达到目标设备。

目标设备收到`SYN`报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回`RST`报文。

客户端收到`RST`报文后，就会释放连接。
# 客户端发送了一个目标 IP 地址存在但是端口不存在的 UDP 报文，UDP 没有像 TCP 那样的 RST 报文，此时会发生什么？
当 UDP 发送一个目标 IP 地址存在但是端口不存在的报文时，接收主机会发送一个 ICMP 端口不可达报文，以通知发送主机该端口不存在。
# 为什么在 TCP 三次握手过程中，如果客户端收到的 SYN-ACK 报文的确认号不符合预期的话，为什么是回 RST，而不是丢弃呢？
{% asset_img 1.png %}

描述下这个场景：
* 客户端向服务端发送`SYN`报文（`seq=100`），但是网络中有个不速之客，一个历史的`SYN`报文（`seq=90`）先抵达服务端；
* 服务端收到历史的`SYN`报文，就会对此`SYN`报文做了确认，回了`SYN-ACK`报文，确认号为`90+1`；
* 客户端收到`SYN-ACK`报文后，诶发现不对劲，他明明发的是`SYN`报文（`seq=100`），按道理`SYN-ACK`报文中的确认号是`100+1`，可现在收到的确认号为`90+1`的`SYN-ACK`报文，所以礼貌地回了`RST`给服务端；
* 服务端收到`RST`报文后，服务端就断开处于`SYN_RECEVIED`状态的连接；
* 最后正常的`SYN`报文（`seq=100`）终于抵达了服务端，经过三次握手后，双方的 TCP 连接都建立完成。
* 
上面这个过程，就是 TCP 三次握手防止历史连接建立的过程，之所以 TCP 需要三次握手，首要原因是为了防止旧的重复连接初始化造成混乱，其次原因是可靠的同步双方的序列号。

那为什么要设计成，当客户端收到不符合期望的`SYN-ACK`报文，是回`RST`，而不是丢弃呢？

现在我们来假设是丢弃处理，看看会发生什么？

{% asset_img 2.jpg %}

可以看到，当处于`SYN_SENT`状态连接的客户端收到不符合期望的`SYN-ACK`报文时，如果选择的处理是「丢弃」，那么双方都会触发超时重传，直到达到最大的重传次数才会进入`CLOSE`状态，这个过程需要持续 10-20 秒。

从客户端的角度看，就是迟迟与服务端建立不来连接，因为服务端这边已经存在一个相同四元组的旧连接，如果不把服务端这个连接干掉，那么是无法确认客户端新的连接（`SEQ=100`），因为非`LISTEN`状态下，如果收到`SYN`，都是回`challenge ack`，这个`ack`并不是对收到`SYN`报做确认，而是继续回复上一次已发送`ACK`。

所以干掉服务端的旧连接的工作，就交给了客户端来做了。

当处于`SYN_SENT`状态连接的客户端，在收到不符合期望的`SYN-ACK`报文时，就直接`RST`给服务端，干掉服务端的旧连接，这样客户端的新连接才能快速建立。