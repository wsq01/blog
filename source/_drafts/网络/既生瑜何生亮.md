

# 既然有 HTTP 协议，为什么还要有 RPC？
作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用`socket`进行编程。

这时候，我们可选项一般也就 TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。除非是马总这种神级程序员（早期QQ大量使用UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。

类似下面这样。
```
fd = socket(AF_INET, SOCK_STREAM, 0);
```
其中`SOCK_STREAM`，是指使用字节流传输数据，说白了就是 TCP 协议。

在定义了`socket`之后，我们就可以愉快的对这个`socket`进行操作，比如用`bind()`绑定 IP 端口，用`connect()`发起建连。

{% asset_img 1.gif 握手建立连接流程 %}

在连接建立之后，我们就可以使用`send()`发送数据，`recv()`接收数据。

光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？不行，这么用会有问题。
## 使用纯裸TCP会有什么问题
TCP是有三个特点，面向连接、可靠、基于字节流。

字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。纯裸 TCP 收发的这些 01 串之间是没有任何边界的，你根本不知道到哪个地方才算一条完整消息。

{% asset_img 2.png %}

正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送"夏洛"和"特烦恼"的时候，接收端收到的就是"夏洛特烦恼"，这时候接收端没法区分你是想要表达"夏洛"+"特烦恼"还是"夏洛特"+"烦恼"。

{% asset_img 3.png %}

这就是所谓的粘包问题。

说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些自定义的规则，用于区分消息边界。

于是我们会把每条要发送的数据都包装一下，比如加入消息头，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体。

{% asset_img 4.png %}

而这里头提到的消息头，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的协议。

每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能有区别，但原理都类似。

于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。
## HTTP和RPC

{% asset_img 5.png %}

TCP 是传输层的协议，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的应用层协议而已。

HTTP协议（`Hyper Text Transfer Protocol`），又叫做超文本传输协议。

而 RPC（`Remote Procedure Call`），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。

举个例子，我们平时调用一个本地方法就像下面这样。
```
res = localFunc(req)
```
如果现在这不是个本地方法，而是个远端服务器暴露出来的一个方法`remoteFunc`，如果我们还能像调用本地方法那样去调用它，这样就可以屏蔽掉一些网络细节，用起来更方便。
```
res = remoteFunc(req)
```

{% asset_img 6.png %}

基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的 gRPC，thrift。

值得注意的是，虽然大部分RPC协议底层使用 TCP，但实际上它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。

既然有HTTP协议，为什么还要有RPC？

其实，TCP 是 70 年代出来的协议，而 HTTP 是 90 年代才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 80 年代出来的 RPC。

所以我们该问的不是既然有 HTTP 协议为什么要有 RPC，而是为什么有 RPC 还要有 HTTP 协议。

那既然有RPC了，为什么还要有HTTP呢？

现在电脑上装的各种联网软件，比如xx管家，xx卫士，它们都作为客户端需要跟服务端建立连接收发消息，此时都会用到应用层协议，在这种 c/s 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。

但有个软件不同，浏览器，不管是 chrome 还是 IE，它们不仅要能访问自家公司的服务器，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一`browser/server (b/s)`的协议。

也就是说在多年以前，HTTP 主要用于 b/s 架构，而 RPC 更多用于 c/s 架构。但现在其实已经没分那么清了，b/s 和 c/s 在慢慢融合。很多软件同时支持多端，比如某度云盘，既要支持网页版，还要支持手机端和 pc 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。

那这么说的话，都用 HTTP 得了，还用什么RPC？

那这就要从它们之间的区别开始说起。
## HTTP和RPC有什么区别
我们来看看 RPC 和 HTTP 区别比较明显的几个点。
### 服务发现
首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口。这个找到服务对应的 IP 端口的过程，其实就是服务发现。

在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。

而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 consul 或者 etcd，甚至是 redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 CoreDNS。

可以看出服务发现这一块，两者是有些区别，但不太能分高低。
### 底层连接形式
以主流的 HTTP1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（`keep alive`），之后的请求和响应都会复用这条连接。

而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。

{% asset_img 7.png %}

由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 go 就是这么干的。

可以看出这一块两者也没太大区别，所以也不是关键。
### 传输的内容
基于 TCP 传输的消息，说到底，无非都是消息头`header`和消息体`body`。

`header`是用于标记一些特殊信息，其中最重要的是消息体长度。

`body`则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 json，protobuf。

这个将结构体转为二进制数组的过程就叫序列化，反过来将二进制数组复原成结构体的过程叫反序列化。

{% asset_img 8.png %}

对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计初是用于做网页文本展示的，所以它传的内容以字符串为主。`header`和`body`都是如此。在`body`这块，它使用 json 来序列化结构体数据。

{% asset_img 9.png %}

可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像`header`里的那些信息，其实如果我们约定好头部的第几位是`content-type`，就不需要每次都真的把`content-type`这个字段都传过来，类似的情况其实在`body`的 json 结构里也特别明显。

而 RPC，因为它定制化程度更高，可以采用体积更小的 protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。

{% asset_img 10.png HTTP原理 %}

{% asset_img 11.png RPC原理 %}

当然上面说的 HTTP，其实特指的是现在主流使用的 HTTP1.1，HTTP2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP2。

那么问题又来了。

为什么既然有了 HTTP2，还要有 RPC 协议？

这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。
## 总结
纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。

RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，不一定非得基于 TCP 协议。

从发展历史来说，HTTP 主要用于 b/s 架构，而 RPC 更多用于 c/s 架构。但现在其实已经没分那么清了，b/s 和 c/s 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。

RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。

HTTP2.0 在 HTTP1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。
# 有了 HTTP 协议，为什么还要有 websocket 协议
## 使用 HTTP 不断轮询
其实问题的痛点在于，怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。

最常见的解决方案是，网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。

这其实时一种「伪」服务器推的形式。

它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。

用这种方式的场景也有很多，最常见的就是扫码登录。

比如，某信公众号平台，登录页面二维码出现之后，前端网页根本不知道用户扫没扫，于是不断去向后端服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于等太久。

{% asset_img 11.png 使用HTTP定时轮询 %}

但这样，会有两个比较明显的问题：
* 当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。
* 最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到明显的卡顿。

使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候卡顿等个 1~2 秒，页面才跳转。

那么问题又来了，有没有更好的解决方案？

有，而且实现起来成本还非常低。
## 长轮询
我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。

如果我们的 HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。

这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。

{% asset_img 12.png 长轮询 %}

比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就秒跳转，体验很好。

像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的长轮询机制。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。

{% asset_img 13.png RocketMQ的消费者通过长轮询获取数据 %}

像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的服务器推送技术，它还有个毫不沾边的英文名，comet 技术，大家听过就好。

上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。

对于像扫码登录这样的简单场景还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。

这就得说下 websocket 了。
## websocket是什么
我们知道 TCP 连接的两端，同一时间里，双方都可以主动向对方发送数据。这就是所谓的全双工。

而现在使用最广泛的 HTTP/1.1，也是基于 TCP 协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。

也就是说，好好的全双工 TCP，被 HTTP/1.1 用成了半双工。

为什么？

这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到客户端发起请求再由服务器响应，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。

所以，为了更好的支持这样的场景，我们需要另外一个基于 TCP 的新协议。

于是新的应用层协议 websocket 就被设计出来了。

虽然名字带了个 socket，但其实 socket 和 websocket 二者毫无关系。

{% asset_img 14.png websocket在四层网络协议中的位置 %}

## 怎么建立websocket连接
浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信。

如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互。

如果这时候是想建立 websocket 连接，就会在 HTTP 请求里带上一些特殊的`header`头，如下：
```
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
```
这些`header`头的意思是，浏览器想升级协议（`Connection: Upgrade`），并且想升级成 websocket 协议（`Upgrade: websocket`）。同时带上一段随机生成的`base64`码（`Sec-WebSocket-Key`），发给服务器。

如果服务器正好支持升级成 websocket 协议。就会走 websocket 握手流程，同时根据客户端生成的`base64`码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的`Sec-WebSocket-Accept`头里，同时带上 101 状态码，发回给浏览器。HTTP 的响应如下：
```
HTTP/1.1 101 Switching Protocols\r\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
```
101 确实不常见，它其实是指协议切换。

{% asset_img 15.png base64转为新的字符串 %}

之后，浏览器也用同样的公开算法将`base64`码转成另一段字符串，如果这段字符串跟服务器传回来的字符串一致，那验证通过。

{% asset_img 16.png 对比客户端和服务端生成的字符串 %}

就这样经历了一来一回两次 HTTP 握手，websocket 就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。

{% asset_img 17.png 建立websocket连接 %}

## websocket抓包
我们可以用 wireshark 抓个包，实际看下数据包的情况。

{% asset_img 18.png 客户端请求升级为websocket %}

上面这张图，注意画了红框的第2445行报文，是websocket的第一次握手，意思是发起了一次带有特殊`Header`的 HTTP 请求。

{% asset_img 19.png 服务器同意升级为websocket协议 %}

上面这个图里画了红框的 4714 行报文，就是服务器在得到第一次握手后，响应的第二次握手，可以看到这也是个 HTTP 类型的报文，返回的状态码是 101。同时可以看到返回的报文 header 中也带有各种 websocket 相关的信息，比如`Sec-WebSocket-Accept`。

{% asset_img 20.png 两次HTTP请求之后正式使用websocket通信 %}

上面这张图就是全貌了，从截图上的注释可以看出，websocket 和 HTTP 一样都是基于 TCP 的协议。经历了三次 TCP 握手之后，利用 HTTP 协议升级为 websocket 协议。

你在网上可能会看到一种说法："websocket 是基于HTTP的新协议"，其实这并不对，因为 websocket 只有在建立连接时才用到了 HTTP，升级完成之后就跟 HTTP 没有任何关系了。

这就有点"借壳生蛋"的那意思。

{% asset_img 21.png HTTP和websocket的关系 %}

## websocket的消息格式
上面提到在完成协议升级之后，两端就会用 webscoket 的数据格式进行通信。

数据包在 websocket 中被叫做帧，我们来看下它的数据格式长什么样子。

{% asset_img 22.png websocket报文格式 %}

这里面字段很多，但我们只需要关注下面这几个。

`opcode`字段：这个是用来标志这是个什么类型的数据帧。比如。
* 等于 1 ，是指`text`类型（`string`）的数据包
* 等于 2 ，是二进制数据类型（`[]byte`）的数据包
* 等于 8 ，是关闭连接的信号

`payload`字段：存放的是我们真正想要传输的数据的长度，单位是字节。比如你要发送的数据是字符串"111"，那它的长度就是3。

{% asset_img 23.png %}

另外，可以看到，我们存放`payload`长度的字段有好几个，我们既可以用最前面的`7bit`, 也可以用后面的`7+16bit`或`7+64bit`。

那么问题就来了。

我们知道，在数据层面，大家都是 01 二进制流。我怎么知道什么情况下应该读`7bit`，什么情况下应该读`7+16bit`呢？

websocket 会用最开始的`7bit`做标志位。不管接下来的数据有多大，都先读最先的7个`bit`，根据它的取值决定还要不要再读个`16bit`或`64bit`。

如果最开始的`7bit`的值是 0~125，那么它就表示了`payload`全部长度，只读最开始的7个bit就完事了。

{% asset_img 24.png %}

如果是126（0x7E）。那它表示`payload`的长度范围在 126~65535 之间，接下来还需要再读`16bit`。这`16bit`会包含`payload`的真实长度。

{% asset_img 25.png %}

如果是127（0x7F）。那它表示payload的长度范围>=65536，接下来还需要再读`64bit`。这`64bit`会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。

{% asset_img 26.png %}

`payload data`字段：这里存放的就是真正要传输的数据，在知道了上面的`payload`长度后，就可以根据这个值去截取对应的数据。

大家有没有发现一个小细节，`websocket`的数据格式也是数据头（内含`payload`长度）+ payload data 的形式。

这是因为 TCP 协议本身就是全双工，但直接使用纯裸 TCP 去传输数据，会有粘包的问题。为了解决这个问题，上层协议一般会用消息头+消息体的格式去重新包装要发的数据。

而消息头里一般含有消息体的长度，通过这个长度可以去截取真正的消息体。

HTTP 协议和大部分 RPC 协议，以及 websocket 协议，都是这样设计的。
## websocket的使用场景
websocket 完美继承了 TCP 协议的全双工能力，并且还贴心的提供了解决粘包的方案。

它适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。

在使用 websocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是服务器逻辑产生的，对玩家产生的伤害等数据，都需要由服务器主动发送给客户端，客户端获得数据后展示对应的效果。
## 总结
TCP 协议本身是全双工的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是半双工的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 websocket 协议。

在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用定时轮询或者长轮询的方式实现服务器推送(comet)的效果。

对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 websocket 协议。

websocket 和 socket 几乎没有任何关系，只是叫法相似。

正因为各个浏览器都支持 HTTP协议，所以 websocket 会先利用 HTTP 协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 websocket 的数据格式进行收发数据。

