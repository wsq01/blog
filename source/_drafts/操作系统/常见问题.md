

# 为什么计算机需要操作系统？
## 资源分配器
如果你的CPU上只需要运行一个程序，那么你的确不需要操作系统。可是，一旦你的CPU上需要再运行一个程序，那么马上就会面临一个问题：两个程序开始竞争资源，因为计算机的硬件就那么多：有限的处理器个数、有限的内存容量、有限的磁盘容量等等，当在只有一个CPU(核)的机器上要运行两个程序时，在某一个时刻CPU到底该运行哪个程序呢？

这显然不是程序1应该关心的事情，当然，也不是程序2该关心的事情，这就需要必须得有一个什么程序来关心，这个程序就是操作系统。

操作系统存在的目的就是为了合理的给各个运行起来后的程序分配资源，从这个角度你可以把操作系统理解为一个资源分配器。

显然你不能把CPU切成多个小的CPU，而只能采用“分时”的策略，也就是“你用一会我用一会”，这就好比大家去游乐场玩过山车，由于过山车只有一个，而且不能拆分成更小的给大家用，因此大家只能排队，你用一会我用一会；

操作系统也采用此策略将CPU资源分配给各个进程，因此从操作系统的角度看“进程A用一会CPU后然后暂停，进程B再用一会儿”，即，操作系统不断的将CPU在各个进程之间切换，只不过切换的速度足够快，因此从用户看来进程在同时运行；操作系统决定以什么样的顺序将CPU分配给各个进程就是所谓的进程调度。

而像内存或者磁盘这类存储资源与CPU不同，我们可以很方便的将内存进行划分，因此可以采用“分块”的策略，也就是“ 你用一块我用一块”，这就是好比停车位，一个停车场中有很多停车位，大家可以同时去停车场中停车。

内存也是同样的道理，我们可以将内存的划分给不同的进程，因此不同的进程可以同时存在于内存中。

为高效使用有限的内存资源，操作系统在内存的使用上可谓绞尽脑汁，虚拟内存就是精彩的发明，其可以让更多进程常驻内存，当然，虚拟内存也带来不小的挑战，这些都需要靠软硬件结合来解决。
## 资源隔离
程序A的运行不能干扰到程序B，即，如果程序A出现bug导致崩溃，那么它不能影响到系统中的其它程序，当然也包括操作系统这个程序；

程序A决不能随意访问程序B所在的内存区域等等，你肯定不希望其它程序能直接获取你的聊天信息，这些都需要操作系统进行资源隔离。

除此之外，复杂的任务需要借助多个程序通力合作才能完成，因此程序之间除了隔离之外也必须进行必要的通信，比如进程间通信等，这时操作系统必须提供必要的同步以及互斥机制，确保程序对共享资源的访问以及程序的运行顺序符合程序员的预期。

因此从这个角度看操作系统又是资源隔离与秩序维护者。
## 细节屏蔽
操作系统和TCP/IP协议栈的作用是类似的，如果没有TCP/IP协议栈，那么在发送网络数据时你需要自己填写好tcp协议header，维护好tcp的链接状态，发送前要进行三次握手，发送的过程中需要保证数据包的可靠传输、还要自己维护tcp的拥塞控制等等，搞定tcp协议还不算完，不要忘了还有ip协议。

除此之外还有数据链路层等等，如果这一切都要自己搞定，相信没有多少程序员能进行网络编程，而且大部分程序员在编写网络程序时相信对这些细节也不感兴趣。

这时tcp/ip协议栈就非常重要了，它通过socket对上层程序员屏蔽了网络的复杂度，程序员仅需要调用send/recv即可进行网络数据的收发，这大大简化了网络编程，因此你可以把内核中负责处理tcp/ip的那一部分理解为计算机网络的”操作系统“。

而操作系统也是同样的道理，我们知道真正完成计算任务的是硬件，hardware，而硬件本身通常是非常难以编程的，尤其设计I/O的部分。

因为这非常的细节、非常琐碎，程序员在读写文件时大概率不想关心要读写的数据到底保存在磁盘的哪个盘面、哪个柱面、哪个扇区上，也不想关心该使用什么样的机器指令可以控制磁盘的读写、怎样平衡好读写速率与磁盘寿命等等，你需要的是两个read/write函数就能读写文件这种抽象概念(实际上从磁盘的角度来说根本不存在文件这种概念)。

这时操作系统的作用就非常明显了，操作系统对上层应用屏蔽了底层的这些细节，让程序员可以将注意力放在自己的领域上。

因此，从这个角度看操作系统更像是一个细节屏蔽者，它提供的一个重要的功能就是：抽象。


# bit、byte、KB、MB、GB、TB...
bit（binary digit）比特，这是表示信息的最小单位,它只能表示 0 或 1。
byte（字节），其表示的值范围是0~255(无符号) 或 -127~127(有符号)，1 byte = 8 bit，一个英文字母1字节，一个汉字需要2字节（GBK编码）。
1 KB = 1024 byte
1 MB = 1024 KB...